<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Auto Sync Shift 샘플</title>
<link rel="stylesheet" type="text/css" href="bridge/WebForm.css" />
<script src="view/lib/jquery-3.2.1.min.js"></script>
<script src="bridge/WinAPI.js"></script>
<script src="bridge/Binder.js"></script>
<script>
Binder.prototype.exitAfterSaveSetting = function(setting) {
	this._.exitAfterSaveSetting(setting);
}
Binder.prototype.openFileDialog = function(type, withSaveSkf) {
	this._.openFileDialog(type, withSaveSkf);
}
Binder.prototype.dropOriginFile = function(withSaveSkf) {
	this._.dropOriginFile(withSaveSkf);
}
Binder.prototype.dropTargetFile = function(withSaveSkf) {
	this._.dropTargetFile(withSaveSkf);
}
Binder.prototype.selectAudio = function(index) {
	this._.selectAudio(index);
}
Binder.prototype.calcShift = function(ranges, shifts) {
	this._.calcShift(ranges, shifts);
}
Binder.prototype.save = function(result, operation) {
	this._.save(result, operation);
}
</script>
<script src="bridge/WebForm.js"></script>
<script src="util/StDev.js"></script>
<script src="util/SyncShift.js"></script>
<script src="util/VideoInfo.js"></script>
<script>
var main = new WebForm();
{	// main
	main.settingJson = '{"saveSkf":{"origin":true,"target":true},"separators":"&nbsp;&nbsp;\\n@harne_"}';
	
	main.run = function() {
		this.initializeComponent();
		
		var settingJson = localStorage.getItem("setting.AutoSyncShift");
		if (settingJson) {
			main.settingJson = settingJson;
		}
		
		main.mainView.src = "view/AutoSyncShift.html";
		main.mainView.onload = function() {
			// 브라우저 샘플에선 url 변형 필요
			main.mainView.contentWindow._open_ = main.mainView.contentWindow.open;
			main.mainView.contentWindow.open = function(url, name, options) {
				if (url.substring(0, 4) != "http") {
					url = location.href.substring(0, location.href.lastIndexOf("/")) + "/view/" + url;
				}
				return main.windows[name] = window_open(url, name, options, main.mainView.contentWindow);
			}
			
			main.mainView.contentWindow.binder = main.binder = new Binder(main);
			// 브라우저 샘플에선 이게 안 도는 경우가 있나?
			/*
			setTimeout(function() {
				main.mainView.contentWindow.binder.initAfterLoad();
			}, 1000);
			*/

			var cd = main.mainView.contentDocument;
			cd.addEventListener("dragenter", function(e) {
				e.preventDefault();
				main.showDragging();
			});
		};
		
		//FormClosing += new FormClosingEventHandler(BeforeExit);
		//FormClosed += new FormClosedEventHandler(WebFormClosed);
	}

	main.initAfterLoad = function() {
		this.super_initAfterLoad();
		this.script("init", [main.settingJson]);
	};
	
	main.beforeExit = function(e) {
		this.script("beforeExit");
	}
	/*
	public void DoExit(bool resetPlayer, bool exitPlayer)

	public void WebFormClosed(object sender, FormClosedEventArgs e)
	*/
}
{
	main.saveSetting = async function(setting) {
		// TODO: C#
	}
}
{
	main.originVideoFile = null;
	main.originSubtitleFile = null;
	main.targetVideoFile = null;
	
	main.isOriginVideoFile = true;
	main.withSaveSkf = true;

	main.showProcessing = function(message) {
		main.script("showProcessing", [message]);
	}
	main.setProgress = function(progress, status) {
		main.script("setProgress", [progress, status]);
	}
	main.hideProcessing = function() {
		main.script("hideProcessing");
	}
	
	main.readingVideoFile = null;
	main.readVideoFile = function(file) {
		console.log("ReadVideoFile: {0}".split("{0}").join(path));
		main.showProcessing("불러오는 중");
		var progress = isOriginVideoFile ? "#originVideo > .input" : "#targetVideo > .input";
		main.readingVideoFile = new VideoInfo(file, new WebProgress(main, progress));
		setTimeout(function() {
			main.readingVideoFile.refreshInfo(main.afterRefreshInfo);
		});
	}
	main.afterRefreshInfo = function(video) {
		console.log("AfterRefreshInfo");
		if (video.length > 0) {
			/*
			if (isOriginVideoFile) {
				originVideoFile = video;
				main.script("setOriginVideoFile", [video.path]);
			} else {
				targetVideoFile = video;
				main.script("setTargetVideoFile", [video.path]);
			}

			var streams = video.streams;

			var audios = [];
			for (int i = 0; i < streams.length; i++) {
				var stream = streams[i];
				console.log("Stream {0}: {1}({2})".split("{0}").join(i).split("{1}").join(stream.type)).split("{2}").join(stream.language));
				foreach (KeyValuePair<string, string> pair in stream.metadata)
				{
					console.log("  {0}: {1}".split("{0}").join(pair.Key).split("{1}").join(pair.Value));
				}
				if (streams[i].type.Equals("audio"))
				{
					audios.Add(i);
				}
			}
			console.log("audios.Count: {0}".split("{0}").join(audios.Count));
			//this.streams = streams;
			switch (audios.Count)
			{
				case 0:
					main.script("alert", "오디오 없음");
					HideProcessing();
					return;
				case 1:
					{
						SelectAudio(audios[0]);
						int index = audios[0];
						StreamAttr audio = streams[index];
						foreach (string key in audio.metadata.Keys)
						{
							console.log(key + ": " + audio.metadata[key]);
						}

						//string.Format("[{0}] {1}", streams[index].language, streams[index].metadata["title"]);
						break;
					}
				default:
					List<object[]> data = new List<object[]>();
					foreach (int index in audios)
					{
						data.Add([index, "[{0}] {1}".split("{0}").join(streams[index].language).split("{1}").join(streams[index].metadata["title"])]);
						console.log("[{0}] {1}".split("{0}").join(streams[index].language).split("{1}").join(streams[index].metadata["title"]));
					}
					//main.script("showAudioSelector", new object[] { Newtonsoft.Json.JsonConvert.SerializeObject(data) });
					break;
			}
			*/
		}
		else
		{
			video.progress.Set(0);
			main.hideProcessing();
		}
	}
	main.selectAudio = function(track) {
		console.log("SelectAudio: {0}".split("{0}").join(track));
		// TODO: C#에서 진행
		if (main.isOriginVideoFile) {
			main.script("refreshRangeAfterReadOriginVideoFile", [originVideoFile.length]);
			setTimeout(function() {
				main.originVideoFile.audioTrackIndex = track;
				main.originVideoFile.refreshSkf();
				if (main.withSaveSkf) {
					main.originVideoFile.saveSkf();
				}
				main.setProgress("#originVideo > .input", 0);
				main.hideProcessing();
			});
		} else {
			setTimeout(function() {
				main.targetVideoFile.audioTrackIndex = track;
				main.targetVideoFile.refreshSkf();
				if (main.withSaveSkf)
				{
					main.targetVideoFile.SaveSkf();
				}
				main.setProgress("#targetVideo > .input", 0);
				main.hideProcessing();
			});
		}
	}
	main.readSkfFile = function(file) {
		var path = file.name;
		console.log("ReadSkfFile: {0}".split("{0}").join(path));
		main.showProcessing("불러오는 중");
		if (main.isOriginVideoFile) {
			main.script("setOriginVideoFile", [path]);
			main.originVideoFile = new VideoInfo(file);
			setTimeout(function() {
				main.originVideoFile.RefreshSkf();
				main.hideProcessing();
			});
		} else {
			main.script("setTargetVideoFile", [path]);
			main.targetVideoFile = new VideoInfo(file);
			setTimeout(function() {
				main.targetVideoFile.RefreshSkf();
				main.hideProcessing();
			});
		}
	}
	main.readSubtitleFile = async function(file) {
		var path = file.name;
		console.log("ReadSubtitleFile: {0}".split("{0}").join(path));
		this.script("setOriginSubtitleFile", [path, await file.text()]);
	}
	main.openFileDialog = async function(type, withSaveSkf) {
		var setting = {types:[{description:'자막 파일',accept:{'text/*':['.smi', '.srt', '.ass']}}]};
		if (type % 10 == 0) {
			// 동영상 혹은 skf 파일
			setting = {types:[{description:'동영상 혹은 skf 파일',accept:{'video/*':['.avi', '.mkv', '.mp4', '.ts', '.m2ts', '.skf']}}]};
		}
		var fb = await window.showOpenFilePicker(setting);
		if (fb && fb[0]) {
			this.droppedFiles = [await fb[0].getFile()];
			switch (Math.floor(type / 10)) {
				case 1: {
					main.dropOriginFile(withSaveSkf);
					break;
				}
				case 2: {
					main.dropTargetFile(withSaveSkf);
					break;
				}
			} 
		}
	}

	main.dropOriginFile = async function(withSaveSkf) {
		console.log("DropOriginFile: {0}".split("{0}").join(withSaveSkf));
		if (!this.droppedFiles) return;
		if (this.droppedFiles.length < 1) {
			this.droppedFiles = null;
			return;
		}
		var hasVideo = false;
		var hasSubtitle = false;
		for (var i = 0; i < this.droppedFiles.length; i++) {
			try {
				var file = this.droppedFiles[i];
				var path = file.name;
				var ext = path.substring(path.length - 4);
				switch (ext) {
					case ".avi":
					case ".mkv":
					case ".mp4":
					case ".ts":
					case ".m2ts": {
						/*
						if (hasVideo) break;
						hasVideo = true;
						main.isOriginVideoFile = true;
						main.withSaveSkf = withSaveSkf;
						main.readVideoFile(file);
						*/
                        if (hasVideo) break;
                        hasVideo = true;
						alert("웹버전은 동영상 대신 skf 파일만 지원합니다.");
						break;
					}
					case ".skf": {
						if (hasVideo) break;
						hasVideo = true;
						main.isOriginVideoFile = true;
						main.readSkfFile(file);
						break;
					}
					case ".smi":
					case ".ass":
					case ".srt": {
						if (hasSubtitle) break;
						hasSubtitle = true;
						main.readSubtitleFile(file);
						break;
					}
				}
				if (hasVideo && hasSubtitle) {
					break;
				}
			} catch (e) {
				console.log(e);
			}
		}
	}
	main.dropTargetFile = function(withSaveSkf) {
		console.log("DropTargetFile: {0}".split("{0}").join(withSaveSkf));
		if (!this.droppedFiles) return;
		if (this.droppedFiles.length < 1) {
			this.droppedFiles = null;
			return;
		}
		var hasVideo = false;
		for (var i = 0; i < this.droppedFiles.length; i++) {
			try {
				var file = this.droppedFiles[i];
				var path = file.name;
				var ext = path.substring(path.length - 4);
				switch (ext) {
					case ".avi":
					case ".mkv":
					case ".mp4":
					case ".ts":
					case ".m2ts": {
						/*
						main.isOriginVideoFile = false;
						main.withSaveSkf = withSaveSkf;
						main.readVideoFile(file);
						*/
                        if (hasVideo) break;
                        hasVideo = true;
                        alert("웹버전은 동영상 대신 skf 파일만 지원합니다.");
						break;
					}
					case ".skf": {
						hasVideo = true;
						main.isOriginVideoFile = false;
						main.readSkfFile(file);
						break;
					}
				}
				if (hasVideo) {
					break;
				}
			} catch (e) {}
		}
	}
	
	main.calcShift = function(strRanges, strShifts) {
		console.log("CalcShift: {0}, {1}".split("{0}").join(strRanges).split("{1}").join(strShifts));

		if (main.originVideoFile == null || main.targetVideoFile == null) {
			main.script("alert", ["파일을 선택해주세요."]);
			return;
		}
		
		main.showProcessing("작업 중");
		
		setTimeout(function() {
			var sRanges = strRanges.length ? strRanges.split('|') : [];
			var sShifts = strShifts.length ? strShifts.split('|') : [];
			var ranges = [];

			if (sRanges.length == 0) {
				main.script("addRange", [0, main.originVideoFile.GetSfs().Count * 10]);
				ranges.push(new Range(0, main.originVideoFile.GetSfs().length));
			} else {
				var shifts = [];
				for (var i = 0; i < sShifts.length; i++) {
					var split = sShifts[i].split(':');
					var start = Math.floor(Number(split[0]) / 10);
					var shift = Math.floor(Number(split[1]) / 10);
					shifts.push(new Range(start, shift));
				}
				
				var last = null;
				for (var i = 0; i < sRanges.length; i++) {
					var split = sRanges[i].split('~');
					var start = Math.floor(Number(split[0]) / 10);
					var end   = Math.floor(Number(split[1]) / 10);
					ranges.push(last = new Range(start, end, last == null ? 0 : last.shift));
					
					for (var j = 0; j < shifts.length; j++) {
						var shift = shifts[j];
						if (shift.start < start) continue;
						if (shift.start >= end) break;

						if (shift.start > start) {
							last.end = shift.start;
							ranges.push(last = new Range(shift.start, end, shift.shift));
						} else {
							last.shift = shift.shift;
						}
					}
				}
			}

			var progress = new WebProgress(main, "#settingCalc");
			/*
			var result = [];
			for (var i = 0; i < ranges.length; i++) {
				var range = ranges[i];
				SyncShift.GetShifts(main.originVideoFile.GetSfs(), main.targetVideoFile.GetSfs()
					, progress, result
					, [range]
					, range.shift);
			}
			*/
			var result = SyncShift.GetShiftsForRanges(main.originVideoFile.GetSfs(), main.targetVideoFile.GetSfs(), ranges, progress);
			
			for (var i = 0; i < result.length; i++) {
				var shift = result[i];
				main.script("addShift", [shift.start * 10, shift.shift * 10]);
			}

			main.hideProcessing();
			main.setProgress("#settingCalc", 0);
		});
	}
	main.save = async function(text, operation) {
		/*
		if (main.targetVideoFile == null) {
			main.script("alert", ["목표 영상 파일을 선택해주세요."]);
			return;
		}
		var path = targetVideoFile.path.Substring(0, targetVideoFile.path.Length - new FileInfo(targetVideoFile.path).Extension.Length) + "." + operation;

		StreamWriter sw = new StreamWriter(path, false, Encoding.UTF8);
		sw.Write(text);
		sw.Close();

		main.script("alert", ["저장했습니다."]);
		*/
		var types = [];
        switch (operation) {
            case "smi": {
                types.push({ description: "SAMI", accept: { "text/sami": [".smi"] } });
                break;
            }
            case "srt": {
                types.push({ description: "SRT", accept: { "text/srt": [".srt"] } });
                break;
            }
            case "ass": {
                types.push({ description: "ASS", accept: { "text/ass": [".ass"] } });
                break;
            }
		}
        var fileBuffer = await window.showSaveFilePicker({ types: types });
        if (fileBuffer) {
            var stream = await fileBuffer.createWritable();
            await stream.write("\ufeff" + text); // BOM 넣어줌
            await stream.close();
            main.script("alert", ["저장했습니다."]);
        }
	}
	/*
	main.readVideoFile = function(path) {
		main.script("showProcessing", [ "불러오는 중" ]);
		var progress = main.isOriginVideoFile ? "#originVideo > .input" : "#targetVideo > .input";
		
		// TODO: C# - ffmpeg
		{
			var i = 0;
			var interval = setInterval(function() {
				if (i == 20) {
					i = 0;
					clearInterval(interval);
				}
				main.setProgress(progress, i++ * 0.05);
			}, 50);
		}
		setTimeout(function() {
			if (true) { // 성공했다고 가정
				if (main.isOriginVideoFile) {
					main.originVideoFilePath = path;
					main.script("setOriginVideoFile", [path]);
				} else {
					main.tragetVideoFilePath = path;
					main.script("setTargetVideoFile", [path]);
				}
				
				// TODO: C#
				var audios = [ "track1", "track2", "track3" ];
				
				if (audios.length == 0) {
					// 오디오가 없을 때
					main.alert("오디오가 없습니다.");
					main.script("hideProcessing");
					
				} else if (audios.length == 1) {
					// 오디오가 하나일 때
					main.selectAudio(audios[0]);
					
				} else {
					// 오디오가 여러 개라고 가정
					main.script("showAudioSelector", [ audios.join("|") ]);
					
				}
				
			} else {
				main.setProgress(progress, 0);
				main.script("hideProcessing");
			}
		}, 1000);
	}
	main.selectAudio = function(track) {
		// TODO: C#에서 진행
		if (main.withSaveSkf) {
			if (main.isOriginVideoFile) {
				console.log("save origin skf");
				main.script("refreshRangeAfterReadOriginVideoFile", [ 142857 ]);
				
			} else {
				console.log("save target skf");
			}
		}
		main.setProgress(main.isOriginVideoFile ? "#originVideo > .input" : "#targetVideo > .input", 0);
		main.script("hideProcessing");
	}
	main.readSkfFile = async function(path) {
		main.script("showProcessing", [ "불러오는 중" ]);
		if (true) { // 성공했다고 가정
			if (main.isOriginVideoFile) {
				main.originVideoFilePath = path;
				main.script("setOriginVideoFile", [path]);
			} else {
				main.targetVideoFilePath = path;
				main.script("setTargetVideoFile", [path]);
			}
			
		} else {
			main.setProgress(main.isOriginVideoFile ? "#originVideo > .input" : "#targetVideo > .input", 0);
			main.script("hideProcessing");
		}
	}
	main.readSubtitleFile = async function(path, file) {
		this.script("setOriginSubtitleFile", [path, await file.text()]);
	}
	main.openFileDialog = async function(type, withSaveSkf) {
		var setting = {types:[{description:'자막 파일',accept:{'text/*':['.smi', '.srt', '.ass']}}]};
		if (type % 10 == 0) {
			// 동영상 혹은 skf 파일
			setting = {types:[{description:'동영상 혹은 skf 파일',accept:{'video/*':['.avi', '.mkv', '.mp4', '.ts', '.m2ts', '.skf']}}]};
		}
		var fb = await window.showOpenFilePicker(setting);
		if (fb && fb[0]) {
			this.droppedFiles = [await fb[0].getFile()];
			switch (Math.floor(type / 10)) {
				case 1: {
					main.dropOriginFile(withSaveSkf);
					break;
				}
				case 2: {
					main.dropTargetFile(withSaveSkf);
					break;
				}
			} 
		}
	}
	main.dropOriginFile = async function(withSaveSkf) {
		if (!this.droppedFiles) return;
		if (this.droppedFiles.length < 1) {
			this.droppedFiles = null;
			return;
		}
		var hasVideo = false;
		var hasSubtitle = false;
		for (var i = 0; i < this.droppedFiles.length; i++) {
			try {
				var file = this.droppedFiles[i];
				var path = file.name;
				var ext = path.substring(path.length - 4);
				switch (ext) {
					case ".avi":
					case ".mkv":
					case ".mp4":
					case ".ts":
					case ".m2ts": {
						if (hasVideo) break;
						hasVideo = true;
						main.isOriginVideoFile = true;
						main.withSaveSkf = withSaveSkf;
						main.readVideoFile(path);
						break;
					}
					case ".skf": {
						if (hasVideo) break;
						hasVideo = true;
						main.isOriginVideoFile = true;
						main.readSkfFile(path);
						break;
					}
					case ".smi":
					case ".ass":
					case ".srt": {
						if (hasSubtitle) break;
						hasSubtitle = true;
						main.readSubtitleFile(path, file);
						break;
					}
				}
				if (hasVideo && hasSubtitle) {
					break;
				}
			} catch (e) {
				console.log(e);
			}
		}
	}
	main.dropTargetFile = function(withSaveSkf) {
		if (!this.droppedFiles) return;
		if (this.droppedFiles.length < 1) {
			this.droppedFiles = null;
			return;
		}
		for (var i = 0; i < this.droppedFiles.length; i++) {
			try {
				var file = this.droppedFiles[i];
				var path = file.name;
				var ext = path.substring(path.length - 4);
				switch (ext) {
					case ".avi":
					case ".mkv":
					case ".mp4":
					case ".ts":
					case ".m2ts": {
						hasVideo = true;
						main.isOriginVideoFile = false;
						main.withSaveSkf = withSaveSkf;
						main.readVideoFile(path);
						break;
					}
				}
			} catch (e) {}
		}
	}
	main.calcShift = async function(ranges) {
		ranges = ranges.split("|");
		for (var i = 0; i < ranges.length; i++) {
			main.script("addShift", [ranges[i].split("~")[0], i * 11111]);
		}
		
		// TODO: C#에서 진행
		main.script("showProcessing", [ "작업 중" ]);
		{
			var i = 0;
			var interval = setInterval(function() {
				if (i == 20) {
					i = 0;
					clearInterval(interval);
				}
				main.setProgress("#settingCalc", i++ * 0.05);
			}, 50);
		}
		setTimeout(function() {
			main.script("hideProcessing");
			main.setProgress("#settingCalc", 0);
		}, 1000);
	}
	main.save = async function(text) {
		
		
		// TODO: C#에서 진행
	}
	*/
}

function WebProgress(main, selector) {
	this.main = main;
	this.selector = selector;
}
WebProgress.prototype.Set = function(ratio) {
	this.main.setProgress(this.selector, ratio);
}

function Range(start, end, shift=0) {
	this.start = start;
	this.end = end;
	this.shift = shift;
}




var Skf = function(sfps, kfps) {
	this.sfps = sfps;
	this.kfps = kfps;
}
Skf.prototype.save = function(path) {}
Skf.prototype.load = function(path) {}
Skf.prototype.getSfps10 = function() {}

var FFmpeg = function(filePath) {
	this.filePath = filePath;
}
FFmpeg.path = null;
FFmpeg.prototype.getVideoInfo = function() {}
FFmpeg.prototype.getVideoLength = function() {}
FFmpeg.prototype.getTracks = function() {}
FFmpeg.prototype.trackToSfps = function(index) {}
FFmpeg.prototype.trackToKfps = function() {}

var CalcShift = function () {
		
};
$(function() {
	main.run();
	window.addEventListener("beforeunload", function(e) {
		main.beforeExit(e);
		return false;
	});
});
</script>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
html, body {
	width: 100%;
	height: 100%;
	border: 0;
	overflow: hidden;
}
</style>
</head>
<body></body>
</html>