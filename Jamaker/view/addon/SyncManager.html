<!doctype html>
<html>
<head>
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<title>화면 싱크 매니저</title>
	<script src="../lib/SubtitleObject.js"></script>
	<script src="../lib/popup.js"></script>
	<script>
windowName = "addon";

// 초기 상태 기억
let tab = null;
const origins = [];

const RANGE = 10; // 현재 싱크 전후로 렌더링할 범위
let mode = 1;
const M = [null, "", "_", "~"]; // 모드에 따른 파일명 끝 표시

ready(() => {
	if (opener && opener.tabs && opener.tabs.length) {
		tab = opener.tabs[opener.tabIndex];
		Subtitle.video = opener.Subtitle.video;
	} else {
		alert("작업 대상이 없습니다.");
		window.close();
		return;
	}
	
    if (!Subtitle.video.fs.length) {
        alert("동영상 프레임 분석이 끝나야 진행할 수 있습니다.");
        window.close();
        return;
	}
    
	if (opener
	 && opener.binder
	 && opener.binder._
	 && (typeof opener.binder._ != "function") // WebView2에서는 선언 안 했어도 function을 반환함
	) {
//		alert("웹샘플에서는 실제 렌더링이 진행되지 않습니다.\n필요 시 SyncManager 대신 구버전 SyncManager0을 활용할 수 있습니다.");
	}
    
    const TX = (opener.setting.sync.uiWidth  ? opener.setting.sync.uiWidth  : 96);
    const TY = (opener.setting.sync.uiHeight ? opener.setting.sync.uiHeight : 54);
    {
	    const styleSize = document.getElementById("styleSize");
	    styleSize.innerHTML = styleSize.innerHTML.replaceAll("96px", TX + "px").replaceAll("54px", TY + "px");
    }
	
	{
		// 현재 선택된 홀드 기준
		const hold = (opener && opener.SmiEditor) ? opener.SmiEditor.selected : null;
		const origin = hold.getText(true);
		origin.hold = hold;
		origin.lines = hold.lines;
		
		origin.start = 0;
		origin.end = 0;
		
		if (hold.isAssHold) {
			// ASS만 작업
			origin.assBody = origin.hold.assEditor.syncs;
			origins.push(origin);
			
		} else {
			if (origin.selection[0] != origin.selection[1]) {
				// 블록지정 있으면 해당 홀드의 선택 범위만 작업
				origin.start = origin.text.substring(0, origin.selection[0]).split("\n").length - 1;
				origin.end   = origin.text.substring(0, origin.selection[1]).split("\n").length;
				origin.assBody = [];
				origins.push(origin);
				
			} else {
				// 전체 작업
			}
		}
	}
	
	let count = 0;
	
	if (origins.length) {
		// 선택된 홀드만 작업
		const origin = origins[0];
		
		const lines = origin.lines.slice(origin.start, origin.end);
		for (let i = 0; i < lines.length; i++) {
			lines[i] = lines[i].TEXT;
		}
		origin.smiFile = new Subtitle.SmiFile(lines.join("\n"));
		count = origin.smiFile.body.length + origin.assBody.length;
		
	} else {
		// 모든 홀드에 대해 작업
		const holds = tab.holds.slice(0);
		holds.push(tab.assHold);
		
		for (let i = 0; i < holds.length; i++) {
			const hold = holds[i];
			const origin = hold.getText(true);
			origin.hold = hold;
			origin.lines = hold.lines;
			
			origin.start = 0;
			origin.end = origin.text.split("\n").length;
			origin.assBody = origin.hold.assEditor ? origin.hold.assEditor.syncs : [];
			
			const lines = origin.lines.slice(origin.start, origin.end);
			for (let i = 0; i < lines.length; i++) {
				lines[i] = lines[i].TEXT;
			}
			origin.smiFile = new Subtitle.SmiFile(lines.join("\n"));
			count += origin.smiFile.body.length + origin.assBody.length;
			
			origins.push(origin);
		}
	}
	
	if (!count) {
		alert("작업 대상이 없습니다.");
		window.close();
		return;
	}
	
	const fs = Subtitle.video.fs;
	const kfs = Subtitle.video.kfs;
	const trustKeyFrame = opener.SmiEditor.trustKeyFrame;
	const renderFromKeyframe = Subtitle.video.path && Subtitle.video.path.endsWith(".m2ts");
	
	const tbody = document.getElementById("editor").querySelector("tbody");
	tbody.innerHTML = "";
	const framesStorage = document.createElement("div");
	
	const frameSyncs = [];
	
	function setFrames(frames, frameIndex, flag) {
		for (let j = -RANGE; j < RANGE; j++) {
			const imgIndex = frameIndex + j;
			const img = document.createElement("img");
			img.classList.add("frame", "img" + imgIndex + flag);
			img.style.left = (j * (TX + 2)) + "px";
			eData(img, { index: imgIndex, offset: j });
			if (trustKeyFrame && Subtitle.findSync(fs[imgIndex], kfs, false)) {
				img.classList.add("keyframe");
			}
			frames.append(img);
		}
	}
	
	for (let oi = 0; oi < origins.length; oi++) {
		const origin = origins[oi];
		
		let lastIndex = -1;
		let count = 0;
		if (origin.smiFile.body) {
			// SMI
			let lastFade = 0;
			for (let i = 0; i < origin.smiFile.body.length; i++) {
				const smi = origin.smiFile.body[i];
				let fade = 0;
				if (smi.text.indexOf("\\fade(")) {
					if (smi.text.indexOf("\\fade(0")) {
						// ASS 페이드인
						fade = 1;
					} else {
						// ASS 페이드아웃
						fade = -1;
					}
				} else {
					// SMI 페이드 여부 확인
					const attrs = smi.toAttrs();
					for (let j = 0; j < attrs.length; j++) {
						const attr = attrs[j];
						if (attr.fade == -1 || attr.fade == 1) {
							fade = attr.fade;
							break;
						}
					}
				}
				
				const tr = document.createElement("tr");
				eData(tr, { oi: oi, smi: smi, origin: smi.start });
				
				const sync = document.createElement("td");
				sync.classList.add("sync");
				
				if (smi.syncType == Subtitle.SyncType.frame) {
					const frameIndex = Subtitle.findSyncIndex(smi.start, fs);
					
					const frames = document.createElement("div");
					frames.classList.add("frames");
					
					setSync(sync, ((frameIndex < fs.length) ? fs[frameIndex] : 99999999));
					framesStorage.append(frames);
					tr.classList.add("fs");
					tr.append(document.createElement("td"), sync);
					frameSyncs.push(tr);

					let flag = "";
					if (fade == 1) {
						// 페이드인 시작 이미지 밝게
						flag = "b";
					} else if (fade == -1) {
						// 페이드아웃 시작 이미지 어둡게
						flag = "d";
					} else if (lastFade == -1) {
						// 페이드아웃 종료 이미지 밝게
						flag = "b";
					} else if (lastFade == 1) {
						// 페이드인 종료 이미지 어둡게
						flag = "d";
					}
					eData(tr, { index: (lastIndex = frameSyncs.length - 1), frames: frames, frameIndex: frameIndex, offset: 0, flag: flag });
					count = 0;
					
					setFrames(frames, frameIndex, flag);
					
				} else {
					sync.innerText = (smi.syncType == Subtitle.SyncType.inner ? "~" : smi.start);
					tr.append(document.createElement("td"), sync);
					eData(tr, { index: (frameSyncs.length - 1) + (++count / 10000) }); // 10000개를 넘어갈 일은 없을 것
				}
				{
					const td = document.createElement("td");
					td.innerText = smi.text.replaceAll("\n", "");
					td.title = smi.text;
					tr.append(td);
					tbody.append(tr);
				}
				
				lastFade = fade;
			}
		}
		if (origin.assBody) {
			// ASS
			for (let i = 0; i < origin.assBody.length; i++) {
				const ass = origin.assBody[i];
				let start = Number(ass.inputStart.value);
				let end   = Number(ass.inputEnd  .value);
				
				{	// start
					const tr = document.createElement("tr");
					eData(tr, { ass: ass, type: "start", origin: start });
					
					const sync = document.createElement("td");
					sync.classList.add("sync");
					
					if (ass.checkStart.checked) {
						const frameIndex = Subtitle.findSyncIndex(start, fs);
						
						const frames = document.createElement("div");
						frames.classList.add("frames");
						
						setSync(sync, ((frameIndex < fs.length) ? fs[frameIndex] : 99999999));
						framesStorage.append(frames);
						tr.classList.add("fs");
						tr.append(document.createElement("td"), sync);
						frameSyncs.push(tr);
						
						// TODO: 페이드는?
						let flag = "";
						
						eData(tr, { index: (lastIndex = frameSyncs.length - 1), frames: frames, frameIndex: frameIndex, offset: 0, flag: flag });
						count = 0;
						
						setFrames(frames, frameIndex, flag);
						
					} else {
						sync.innerText = start;
						tr.append(document.createElement("td"), sync);
						eData(tr, { index: (frameSyncs.length - 1) + (++count / 1000) }); // 1000개를 넘어갈 일은 없을 것
					}
					{
						const assText = ass.inputText.value;
						const td = document.createElement("td");
						td.rowSpan = 2;
						td.innerText = assText.replaceAll("\n", "");
						td.title = assText.replaceAll("{", "\n{").replaceAll("}", "}\n");
						tr.append(td);
						tbody.append(tr);
					}
				}
				
				{	// end
					const tr = document.createElement("tr");
					eData(tr, { ass: ass, type: "end", origin: end });
					
					const sync = document.createElement("td");
					sync.classList.add("sync");
					
					if (ass.checkEnd.checked) {
						const frameIndex = Subtitle.findSyncIndex(end, fs);

						const frames = document.createElement("div");
						frames.classList.add("frames");
						
						setSync(sync, ((frameIndex < fs.length) ? fs[frameIndex] : 99999999));
						framesStorage.append(frames);
						tr.classList.add("fs");
						tr.append(document.createElement("td"), sync);
						frameSyncs.push(tr);
						
						// TODO: 페이드는?
						let flag = "";
						
						eData(tr, { index:(lastIndex = frameSyncs.length - 1), frames: frames, frameIndex: frameIndex, offset: 0, flag: flag });
						count = 0;
						
						setFrames(frames, frameIndex, flag);
						
					} else {
						sync.innerText = end;
						tr.append(document.createElement("td"), sync);
						eData(tr, { index: lastIndex + (++count / 10000) }); // 10000개를 넘어갈 일은 없을 것
					}
					tbody.append(tr);
				}
			}
		}
	}
	
	function renderThumbnails() {
		const datas = [];
		[...tbody.querySelectorAll("tr.fs")].forEach((tr) => {
			datas.push(eData(tr));
		});
		// ASS 지원하면서 정렬 기능이 필요해짐
		datas.sort((a, b) => {
			return a.frameIndex - b.frameIndex;
		});
		
		const renderList = [];
		let renderGroup = { end: -11 };
		
		for (let i = 0; i < datas.length; i++) {
			const data = datas[i];
			
			const begin = data.offset + (data.frameIndex < RANGE ? 0 : data.frameIndex - RANGE);
			const end   = data.offset + (data.frameIndex + RANGE > fs.length ? fs.length : data.frameIndex + RANGE);
			
			let fs0 = fs[begin];
			if (renderFromKeyframe) {
				// 필요한 프레임 바로 앞 키프레임 찾기
				let index = Subtitle.findSyncIndex(fs0, kfs);
				if (kfs[index] > fs0) {
					index--;
				}
				fs0 = kfs[index];
			}
			
			if ((renderGroup.flag == data.flag)
			 && (fs0 < fs[renderGroup.end] + 500) // 렌더링에 필요한 프레임이 앞쪽과 500ms 이내로 이어질 때
			) {
				renderGroup.end = end;
				
			} else {
				renderList.push(renderGroup = {
						flag: data.flag
					,	time: fs0 // 다시 테스트해보니 여긴 반올림 대신 버림 하는 게 맞음
					,	begin: begin
					,	end: end
				});
			}
			
			let imgs = [...data.frames.children];
			for (let j = data.offset - RANGE; j < data.offset + RANGE; j++) {
				const imgIndex = data.frameIndex + j;
				const cName = "img" + imgIndex + data.flag;
				if (!data.frames.querySelector("." + cName)) {
					const img = document.createElement("img");
					img.classList.add("frame", cName);
					img.style.left = (j * (TX + 2)) + "px";
					eData(img, { index: imgIndex, offset: j });
					if (trustKeyFrame && Subtitle.findSync(fs[imgIndex], kfs, false)) {
						img.classList.add("keyframe");
					}
					imgs.push(img);
				}
			}
			imgs.sort((a, b) => {
				const v = eData(a).index - eData(b).index;
				return (v > 0) ? 1 : ((v < 0) ? -1 : 0);
			});
			imgs.forEach((img) => {
				data.frames.append(img);
			});
		};
		if (renderList.length == 0) {
			return false;
		}
		
		// 이미지 렌더링 요청
		let params = [];
		for (let i = 0; i < renderList.length; i++) {
			const group = renderList[i];
			// [ 시작시간, 길이, 시작인덱스, 종료인덱스, 플래그 ]
			params.push([group.time, fs[group.end] - group.time, group.begin, group.end, group.flag].join(","));
		}
		opener.binder.renderThumbnails(Subtitle.video.path, params.join("\n"));
		return true;
	}
	if (!renderThumbnails()) {
		alert("작업 대상이 없습니다.");
		window.close();
		return;
	}
	
	let fileSeq = 0;
	opener.setThumbnailsFileSeq = function(thumbnailsFileSeq) {
		fileSeq = thumbnailsFileSeq;
	}
	
	// 렌더링 중일 때 색깔 넣어줌
	opener.startRenderThumbnails = function(begin, end, flag) {
		for (let i = begin; i < end; i++) {
			const imgs = [...tbody.querySelectorAll(`img.img${i}${flag}`)];
			imgs.push(...framesStorage.querySelectorAll(`img.img${i}${flag}`));
            imgs.forEach((img) => {
				img.classList.add("rendering");
			});
		}
		document.body.dispatchEvent(new Event("scroll", { bubbles: true }));
	}
	opener.startCompareThumbnails = function (begin, end, flag) {
        for (let i = begin; i < end; i++) {
            const imgs = [...tbody.querySelectorAll(`img.img${i}${flag}`)];
            imgs.push(...framesStorage.querySelectorAll(`img.img${i}${flag}`));
			imgs.forEach((img) => {
				img.classList.remove("rendering");
				img.classList.add("comparing");
			});
		}
		document.body.dispatchEvent(new Event("scroll", { bubbles: true }));
	}
	
	// 렌더링 완료 후 이미지 세팅
	// 미리 값을 넣어주면 삭제되지 않은 다른 영상 섬네일 가져올 수 있음
	opener.afterRenderThumbnails = function(begin, end, flag) {
        for (let i = begin; i < end; i++) {
            const imgs = [...tbody.querySelectorAll(`img.img${i}${flag}`)];
            imgs.push(...framesStorage.querySelectorAll(`img.img${i}${flag}`));
			imgs.forEach((img) => {
				img.classList.remove("comparing");
				eData(img, { img: i + flag });
			});
		}
		document.body.dispatchEvent(new Event("scroll", { bubbles: true }));
	}
	// 차이 비교값... 현재 쓰이지 않음...
	const diffs = {};
	opener.setDiff = function(key, diff) {
		diffs[key] = diff;
	}
	
	window.selected = -1;
	function select(index, tr=null) {
		if (selected == index) return;
		
		const byKeyboard = (tr === true);
		let scrollMargin = 30;
		
		if (byKeyboard) {
			tr = null;
			scrollMargin = opener.setting.scrollMargin * 30;
		}
		
		selected = index;
		if (tr == null) {
			tr = frameSyncs[selected];
		}
		
		tbody.querySelector("tr.selected")?.classList.remove("selected");
		tr.classList.add("selected");
		
		const offsetTop = tr.offsetTop - document.body.scrollTop;
		if (offsetTop < (byKeyboard ? scrollMargin : 0)) {
			document.body.scrollTo({
					top: tr.offsetTop - scrollMargin
				,	left: 0
				,	behavior: "smooth"
			});
		} else {
			const bottom = offsetTop + TY + 2;
			const margin = document.body.clientHeight - bottom;
			if (margin < (byKeyboard ? scrollMargin : 0)) {
				document.body.scrollTo({
						top: document.body.scrollTop - margin + scrollMargin
					,	left: 0
					,	behavior: "smooth"
				});
			}
		}
	}
	function setSync(td, sync) {
		td.innerText = (sync == 0 ? 1 : sync);
		if (!trustKeyFrame) return;
		if (Subtitle.findSync(sync, kfs, false)) {
			td.classList.add   ("keyframe");
		} else {
			td.classList.remove("keyframe");
		}
	}
	function moveSync(direction, isOffset=false) {
		const tr = frameSyncs[selected];
		const data = eData(tr);
		
		const offset = isOffset ? direction : (data.offset + direction);
		//if (offset < -12 || offset >= 12) return;
		
		const index = data.frameIndex + offset;
		if (index < 0) return;
		
		eData(tr, { offset: offset });
		data.frames.style.left = (`calc(50% - ${ offset * (TX + 2) }px)`);
		
		setSync(tr.querySelector("td.sync"), fs[index]);
	}
	
	function apply() {
		const smis = [];
		for (let oi = 0; oi < origins.length; oi++) {
			smis[oi] = [];
		}
		let countSmi = 0;
		[...tbody.querySelectorAll("tr")].forEach((tr) => {
			const data = eData(tr);
			if (data.smi) {
				if (tr.classList.contains("fs")) {
					data.smi.start = Number(tr.querySelector(".sync").innerText);
				}
				smis[data.oi].push(data.smi);
				countSmi++;
				
			} else if (data.ass && tr.classList.contains("fs")) {
				const sync = Number(tr.querySelector(".sync").innerText);
				if (data.type == "start") {
					data.ass.inputStart.value = sync;
				} else if (data.type == "end") {
					data.ass.inputEnd.value = sync;
				}
				data.ass.update();
			}
		});
		if (!countSmi) {
			// SMI 내역 없음 = ASS 편집
			return;
		}
		
		// 중간 싱크 재계산
		for (let oi = 0; oi < origins.length; oi++) {
			const hold = smis[oi];
			
			let startIndex = -1;
			for (let i = 1; i < hold.length; i++) {
				if (hold[i].syncType == Subtitle.SyncType.inner) {
					if (startIndex < 0) {
						startIndex = i - 1;
					}
				} else {
					if (startIndex >= 0) {
						const endIndex = i;
						const startSync = hold[startIndex].start;
						const endSync   = hold[endIndex  ].start;
						const count = endIndex - startIndex;
						
						for (let j = 1; j < count; j++) {
							hold[startIndex + j].start = Math.round(((count - j) * startSync + j * endSync) / count);
						}
						startIndex = -1;
					}
				}
			}
		}
		
		for (let oi = 0; oi < origins.length; oi++) {
			const origin = origins[oi];
			
			const result = new Subtitle.SmiFile();
			result.header = origin.smiFile.header;
			result.footer = origin.smiFile.footer;
			result.body = smis[oi];
			
			// 해당 줄 앞뒤 전체 선택되도록 조정
			const origLines = origin.text.split("\n");
			const prev = origLines.slice(0, origin.start).join("\n");
			const next = origLines.slice(origin.end).join("\n");
			
			// 에디터에 적용
			const text = (prev ? prev + "\n" : "") + result.toText() + (next ? "\n" + next : "");
			// 현재 커서 위치를 기반으로 다시 맞춤
			const selectedLine = origin.hold.input.value.substring(0, origin.hold.input.selectionEnd).split("\n").length;
			const cursor = text.split("\n").slice(0, selectedLine - 1).join("\n").length + 1;
			origin.hold.history.log();
			origin.hold.setText(text, [cursor]);
		}
	}
	
	tbody.addEventListener("click", (e) => {
		let el;
		if (el = e.target.closest("tr")) {
			select(eData(el).index, el);
		}
		if (el = e.target.closest("img.frame")) {
			select(eData(el.closest("tr")).index);
			moveSync(eData(el).offset, true);
		}
	});
	tbody.addEventListener("dblclick", (e) => {
		const tr = e.target.closest("tr.fs");
		if (tr) {
			// 에디터 해당 싱크로 이동
			opener.SmiEditor.selected.findSync(Number(tr.querySelector("td.sync").innerText) + 1);
		}
	});
	
	document.addEventListener("keydown", (e) => {
		switch (e.key) {
			case "ArrowUp": {
				e.preventDefault();
				if (e.ctrlKey || selected == 0) {
					document.body.scrollTo({
							top: document.body.scrollTop - (TY + 2)
						,	left: 0
						,	behavior: "smooth"
					});
					break;
				}
				if (selected > 0) {
					if (selected % 1) {
						select(Math.floor(selected), true);
					} else {
						select(selected - 1, true);
					}
				}
				break;
			}
			case "ArrowDown": {
				e.preventDefault();
				if (e.ctrlKey || selected == frameSyncs.length - 1) {
					document.body.scrollTo({
							top: document.body.scrollTop + (TY + 2)
						,	left: 0
						,	behavior: "smooth"
					});
					break;
				}
				if (selected < frameSyncs.length - 1) {
					if (selected % 1) {
						select(Math.ceil(selected), true);
					} else {
						select(selected + 1, true);
					}
				}
				break;
			}
			case "ArrowLeft": {
				moveSync(-1);
				break;
			}
			case "ArrowRight": {
				moveSync(+1);
				break;
			}
			case "Delete": {
				moveSync(0, true);
				break;
			}
			case "q": {
				if (!e.shiftKey && e.ctrlKey && !e.altKey) {
					opener.binder.moveTo(Number(frameSyncs[selected].querySelector(".sync").innerText) - 2000);
				}
				break;
			}
		}
	});
	document.addEventListener("keydown", (e) => {
		if (e.target.closest("input[name=mode]")) {
			// 모드 선택 후에도 방향키 조작은 원래대로 동작해야 함
			e.preventDefault();
		}
	});
	
	tbody.addEventListener("load", function(e) {
		if (e.target.closest("img")) {
			// 이미지 로딩 성공 후엔 추가 갱신 없도록 함
			eData(this, { img: null });
		}
	});
	function refreshImages(imgs) {
		[...imgs].forEach(function (img) {
			const imgKey = eData(img).img;
			if (imgKey) {
				img.src = (`../../temp/thumbnails/${fileSeq}_${imgKey}${M[mode]}.jpg`);
			}
		});
	}
	function showFrames(tr) {
		const showing = tr.classList.contains("showing");
		const frames = eData(tr).frames;
		refreshImages(frames.querySelectorAll("img"));
		if (!showing) {
			tr.classList.add("showing");
			tr.querySelector("td").append(frames);
		}
	}
	function hideFrames(tr) {
		if (tr.classList.contains("showing")) {
			tr.classList.remove("showing");
		}
		framesStorage.append(eData(tr).frames);
	}
	window.addEventListener("resize", (e) => {
		document.body.dispatchEvent(new Event("scroll", { bubbles: true }));
	});
	document.body.addEventListener("scroll", (e) => {
		let status = -1;
		[...document.querySelectorAll("#editor tbody tr.fs")].forEach((tr) => {
			
			if (status < 1) {
				const offsetTop = tr.offsetTop - document.body.scrollTop; 
				
				if (status < 0) {
					if (offsetTop + TY + 2 < 0) {
						// 위쪽에 있어서 안 보임
						hideFrames(tr);
						return;
					}
				}
				if (offsetTop > document.body.clientHeight) {
					// 아래쪽에 있어서 안 보임
					hideFrames(tr);
					return;
				}
				
				showFrames(tr);
				
			} else {
				// 아래쪽에 있어서 안 보임
				hideFrames(tr);
			}
		});
	});
	document.body.dispatchEvent(new Event("scroll", { bubbles: true }));
	
	document.getElementById("inputShift").addEventListener("keydown", (e) => {
		// 가중치 입력 중엔 방향키 조작 차단
		e.stopPropagation();
	});
	
	const form = document.getElementById("formShift");
	form.addEventListener("submit", (e) => {
		e.preventDefault();
		
		const shift = Number(document.getElementById("inputShift").value);
		[...document.querySelectorAll("#editor tbody tr.fs")].forEach((tr) => {
			const data = eData(tr);
			const frameIndex = Subtitle.findSyncIndex(data.origin, fs);
			const shiftIndex = Subtitle.findSyncIndex(data.origin + shift, fs);
			const offset = shiftIndex - frameIndex;
			eData(tr, { offset: offset });
			data.frames.style.left = (`calc(${ -(TX + 2) * offset }px + 50%`);
			setSync(tr.querySelector("td.sync"), fs[shiftIndex]);
		});
	});
	form.addEventListener("click", (e) => {
		if (e.target.closest("input[name=mode]")) {
			mode = form.querySelector("input[name=mode]:checked").value;
			refreshImages(tbody.querySelectorAll("img"));
			for (let i = 1; i <= 3; i++) {
				if (i == mode) {
					document.body.classList.add   ("mode" + i);
				} else {
					document.body.classList.remove("mode" + i);
				}
			}
		}
	});
	
	document.getElementById("btnApply").addEventListener("click", () => {
		apply();
		// 조정한 타이밍에 맞춰서 추가 렌더링
		renderThumbnails();
	});
	document.getElementById("btnSet").addEventListener("click", () => {
		apply();
		window.close();
	});
	
	// 페이지 벗어날 경우 렌더링 취소
	window.onunload = function () {
		opener.binder.cancelRenderThumbnails();
	}
	
	select(0);
});
	</script>
	<style>
body {
	overflow-y: scroll;
}
#editorLayer {
	position: relative;
}
#editor {
	width: 100%;
	border: 0;
	table-layout: fixed;
}
#editor tr {
	color: #888;
}
#editor tr.fs {
	color: #000;
}
#editor tr.selected td {
	background: #ffc;
}
#editor td {
	overflow: hidden;
	padding: 4px 2px;
}
#editor td:first-child {
	position: relative;
	border-left: 0;
}
#editor td.sync {
	text-align: right;
}
#editor td.sync.keyframe {
	font-weight: bold;
}
#editor td:last-child {
	white-space: pre;
	border-right: 0;
}
#editor .frames {
	position: absolute;
	top: 0;
	left: 50%;
	transition: 0.2s;
}
#editor .frame {
	display: block;
	position: absolute;
	top: 0;
	border: 1px solid #888;
	cursor: pointer;
	transition: 0.2s;
}
#editor .frame.keyframe {
	border-left-color: #f88;
}
#editor .frame.rendering {
	background: #fee;
}
#editor .frame.comparing {
	background: #efe;
}
#editor .frame:hover {
	border-color: #f88;
	opacity: 0.8;
}
.frameChecker {
	position: absolute;
	top: 0;
	width: 1px;
	background: #f0f;
	bottom: 0;
	border: 0;
	transition: 0.2s;
}
#formShift, #btnApply, #btnSet {
	position: fixed;
	opacity: 0.5;
	right: 0;
}
#formShift:hover, #btnApply:hover {
	opacity: 1;
}
#formShift {
	top: 0;
	border: 0 solid #aaa;
	border-width: 0 0 1px 1px;
	background: #fff;
	width: 160px;
	padding: 4px;
}
#inputShift {
	width: 50px;
}
#btnShift {
	width: 50px;
}
#btnApply {
	width: 100px;
	height: 30px;
	bottom: 30px;
}
#btnSet {
	width: 100px;
	height: 30px;
	bottom: 0;
}
	</style>
	<style id="styleSize">
#editor tr.fs {
	height: calc(54px + 3px);
}
#editor .frame {
	height: calc(54px + 2px);
}
#editor .frame {
	width: calc(96px + 2px);
	height: calc(54px + 2px);
}
.frameChecker.left  { left: calc(35% - 1.5px); }
.frameChecker.right { left: calc(35% - 0.5px); }
body:not(.mode1) #editor .frames {
	margin-left: calc(-96px / 2 - 1px);
}
body:not(.mode1) .frameChecker.left  { left: calc(35% - (96px / 2) - 1.5px); }
body:not(.mode1) .frameChecker.right { left: calc(35% + (96px / 2) + 0.5px); }
body:not(.mode1) .frame:first-child { margin-left: calc(96px + 2px); }
	</style>
</head>
<body class="mode1">
	<div id="editorLayer">
		<table id="editor">
			<colgroup>
				<col style="width: 70%;" />
				<col style="width: 80px;" />
				<col />
			</colgroup>
			<thead></thead>
			<tbody></tbody>
			<tfoot></tfoot>
		</table>
		<div class="frameChecker left"></div>
		<div class="frameChecker right"></div>
	</div>
	<form id="formShift"><label>가중치 <input id="inputShift" type="number" value="0" /></label><button type="submit" id="btnShift">초기화</button>
		<ol>
			<li title="Alt+1"><label><input type="radio" name="mode" value="1" accesskey="1" checked /> 기본</label></li>
			<li title="Alt+2"><label><input type="radio" name="mode" value="2" accesskey="2" /> 이전 프레임과 차이</label></li>
			<li title="Alt+3"><label><input type="radio" name="mode" value="3" accesskey="3" /> 밝기 변화</label></li>
		</ol>
	</form>
	<button type="button" id="btnApply" title="Alt+A" accesskey="a">적용</button>
	<button type="button" id="btnSet"   title="Alt+S" accesskey="s">적용 후 닫기</button>
</body>
</html>