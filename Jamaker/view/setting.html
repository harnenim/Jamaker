<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>설정</title>
<script src="lib/jquery-3.2.1.min.js"></script>
<script src="lib/popup.js"></script>
<script src="lib/History.js"></script>
<script src="lib/SmiEditor.js"></script>
<link rel="stylesheet" type="text/css" href="lib/popup.css" />
<link rel="stylesheet" type="text/css" href="lib/SmiEditor.css" />
<script>
windowName = "setting";

function show(index) {
	$("#settingNav > a.selected").removeClass("selected");
	$("#settingNav > a:eq(" + index + ")").addClass("selected");
	$("#settingArea > form.selected").removeClass("selected");
	opened = $("#settingArea > form:eq(" + index + ")").addClass("selected").attr("id");
	opener.setting.show = index;
}
let opened = null;
const submitFuncs = {};
const refreshFuncs = {};
let refreshTableCommand = () => {};

const saved = {};
function checkSaved(key, ok, no) {
	if (saved[key].status) {
		if (ok) ok();
		return;
	}
	confirm(saved[key].name + " 변경사항이 사라집니다.", ok, no);
}
function setSaved(key, status) {
	const item = saved[key];
	if (item) {
		item.status = status;
	}
}
function requestClose(keys) {
	if (!keys) {
		keys = [];
		for (let key in saved) {
			keys.push(key);
		}
	}
	if (keys.length) {
		for (let i = 0; i < keys.length; i++) {
			const key = keys[i];
			checkSaved(key, () => {
				requestClose(keys.slice(i + 1));
			});
			success = false;
			break;
		}
	} else {
		window.close();
	}
}

$(() => {
	const setting = JSON.parse(JSON.stringify(opener.setting));
	const oSmiEditor = opener.SmiEditor;
	
	function refresh(form, setting) {
		form.find("input[type=text][name],input[type=number][name],input[type=color][name],input[type=range][name],textarea[name]").each((_, el) => {
			const input = $(el);
			let name = input.attr("name");
			if (name.indexOf("what") > 0) {
				name = name.split("what").join(setting.player.control.dll);
			}
			const value = eval("setting['" + name.split("_").join("']['") + "']");
			if (typeof value == "number" || typeof value == "string") {
				input.val(value);
			} else if (value && value.join) {
				input.val(value.join("\n"));
			}
		});
		form.find("input[type=checkbox][name]").each((_, el) => {
			const input = $(el);
			let name = input.attr("name");
			if (name.indexOf("what")) {
				name = name.split("what").join(setting.player.control.dll);
			}
			input.prop("checked", eval("setting['" + name.split("_").join("']['") + "']"));
		});
		form.find("select[name]").each((_, el) => {
			const select = $(el);
			const name = select.attr("name");
			const value = eval("setting." + name.split("_").join("."));
			select.data({value: value});
		});
	}
	
	const fieldEditor = $("#fieldEditor");
	const fieldViewer = $("#fieldViewer");
	const fieldPlayer = $("#fieldPlayer");

	const tableCommand = $("#tableCommand");
	const inputCommandName = $("#inputCommandName");
	const inputCommandKey  = $("#inputCommandKey" );
	const inputCommandFunc = $("#inputCommandFunc");

	{	// 창
		(refreshFuncs["window"] = (setting) => {
			refresh($("#window"), setting);
			
			// 값에 맞춰 fieldset 이동
			const editor = [setting.window       , fieldEditor];
			const viewer = [setting.viewer.window, fieldViewer];
			const player = [setting.player.window, fieldPlayer];
			
			{
				const ecss = {};
				const vcss = {};
				const pcss = {};
				
				function setLeft(css, x) {
					css.left = x + 1;
				}
				function setRight(css, x) {
					css.width = (x - css.left - 2) + "%";
					css.left = css.left + "%";
				}
				function setTop(css, y) {
					css.top = y + 1;
				}
				function setBottom(css, y) {
					css.height = (y - css.top - 2) + "%";
					css.top = css.top + "%";
				}
				
				const targetXY = [
					[	[ editor[0].x, (x) => { setLeft(ecss, x); } ]
					,	[ editor[0].x + editor[0].width, (x) => { setRight(ecss, x); } ]
					,	[ viewer[0].x, (x) => { setLeft(vcss, x); } ]
					,	[ viewer[0].x + viewer[0].width, (x) => { setRight(vcss, x); } ]
					,	[ player[0].x, (x) => { setLeft(pcss, x); } ]
					,	[ player[0].x + player[0].width, (x) => { setRight(pcss, x); } ]
					]
				,	[	[ editor[0].y, (y) => { setTop(ecss, y); } ]
					,	[ editor[0].y + editor[0].height, (y) => { setBottom(ecss, y); } ]
					,	[ viewer[0].y, (y) => { setTop(vcss, y); } ]
					,	[ viewer[0].y + viewer[0].height, (y) => { setBottom(vcss, y); } ]
					,	[ player[0].y, (y) => { setTop(pcss, y); } ]
					,	[ player[0].y + player[0].height, (y) => { setBottom(pcss, y); } ]
					]
				];
				for (let xy = 0; xy < 2; xy++) {
					const targets = targetXY[xy];
					targets.sort((a, b) => { return a[0] - b[0]; });
					
					let last = [targets[0]];
					const ps = [last];
					for (let i = 1; i < targets.length; i++) {
						const curr = targets[i];
						if (curr[0] == last[0][0]) {
							last.push(curr);
						} else {
							last = [curr];
							ps.push(last);
						}
					}
					function getPos(i) {
						return 1 + ((98 / (ps.length - 1)) * i);
					}
					for (let i = 0; i < ps.length; i++) {
						const curr = ps[i];
						for (let j = 0; j < curr.length; j++) {
							curr[j][1](getPos(i));
						}
					}
				}
				fieldEditor.css(ecss);
				fieldViewer.css(vcss);
				fieldPlayer.css(pcss);
			}
			
			setSaved("window"
				,  (JSON.stringify(setting.window) == JSON.stringify(opener.setting.window))
				&& (JSON.stringify(setting.viewer.window) == JSON.stringify(opener.setting.viewer.window))
				&& (JSON.stringify(setting.player.window) == JSON.stringify(opener.setting.player.window))
			);
		})(setting);
	
		submitFuncs["window"] = () => {
			setting.window.x             = Number($("input[name=window_x]"            ).val());
			setting.window.y             = Number($("input[name=window_y]"            ).val());
			setting.window.width         = Number($("input[name=window_width]"        ).val());
			setting.window.height        = Number($("input[name=window_height]"       ).val());
			setting.viewer.window.x      = Number($("input[name=viewer_window_x]"     ).val());
			setting.viewer.window.y      = Number($("input[name=viewer_window_y]"     ).val());
			setting.viewer.window.width  = Number($("input[name=viewer_window_width]" ).val());
			setting.viewer.window.height = Number($("input[name=viewer_window_height]").val());
			setting.player.window.x      = Number($("input[name=player_window_x]"     ).val());
			setting.player.window.y      = Number($("input[name=player_window_y]"     ).val());
			setting.player.window.width  = Number($("input[name=player_window_width]" ).val());
			setting.player.window.height = Number($("input[name=player_window_height]").val());
			setting.player.window.use    = $("input[name=player_window_use]").prop("checked");
			setting.window.follow        = $("input[name=window_follow]").prop("checked");
			opener.setSetting(setting);
			opener.saveSetting();
			opener.moveWindowsToSetting();
			setTimeout(() => { // 딜레이 줘야 정상적으로 계산됨
				opener.refreshPaddingBottom();
			}, 10);
			refreshFuncs["window"](setting);
		};
		
		$("#btnGetWindows").on("click", function() {
			opener.binder.getWindows(["editor", "viewer", "player"]);
		});
		// C#에서 Script("afterGetWindow", object[] { "editor", x, y, w, h });
		opener.afterGetWindow = (id, x, y, w, h) => {
			const name = (id == "editor")
			           ? "window"
			           : (id + "_window");
			$("input[name=" + name + "_x]"     ).val(x);
			$("input[name=" + name + "_y]"     ).val(y);
			$("input[name=" + name + "_width]" ).val(w);
			$("input[name=" + name + "_height]").val(h);
		};
	}
	
	{	// 싱크
		(refreshFuncs["sync"] = (setting) => {
			refresh($("#sync"), setting);
			setSaved("sync", (JSON.stringify(setting.sync) == JSON.stringify(opener.setting.sync)));
		})(setting);
		
		submitFuncs["sync"] = () => {
			const preset = $("input[name=sync_preset]").val();
			
			// TODO: 프리셋 양식 오류 검증 필요?
			// <Sync Start={sync}><P Class={lang}{type}>
			
			setting.sync.insert = Number($("input[name=sync_insert]").val());
			setting.sync.update = Number($("input[name=sync_update]").val());
			setting.sync.weight = Number($("input[name=sync_weight]").val());
			setting.sync.unit   = Number($("input[name=sync_unit]"  ).val());
			setting.sync.move   = Number($("input[name=sync_move]"  ).val());
			setting.sync.lang   = $("input[name=sync_lang]"  ).val();
			setting.sync.preset = preset;
			setting.sync.frame  = $("input[name=sync_frame]" ).prop("checked");
			setting.sync.kframe = $("input[name=sync_kframe]").prop("checked");
			setting.sync.kLimit = Number($("input[name=sync_kLimit]").val());
			setting.sync.holds  = $("input[name=sync_holds]").prop("checked");
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 단축키
		saved.cmd = { status: true, name: "단축키 설정" };
		
		refreshFuncs["cmd"] = (setting) => {
			if (setting == opener.setting) {
				checkSaved("cmd", () => {
					setSaved("cmd", true);
					inputCommandName.val("");
					inputCommandKey .val("");
					inputCommandFunc.val("");
				});
				
			} else {
				confirm("현재 값은 복원할 수 없습니다.", () => {
					opener.setting.command = opener.deepCopyObj(setting.command);
					setSaved("cmd", true);
					inputCommandName.val("");
					inputCommandKey .val("");
					inputCommandFunc.val("");
					refreshTableCommand();
					opener.setSetting(opener.setting);
					opener.saveSetting();
				});
			}
		};
		
		const tbody = tableCommand.find("tbody");
		const withs = ["withCtrls", "withAlts", "withCtrlAlts", "withCtrlShifts"];
		const keys = "pqrstuvwxyz{ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890";
		const keyNames = ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12"].concat("ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890".split(""));
		(refreshTableCommand = () => {
			tbody.empty();
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				const keyName = (i < 12)
				              ? ("F" + (i + 1))
				              : key;
				const th = $("<th>").text(keyName);
				if (i < 12) {
					let func = setting.command.fn[key];
					if (!func || !func.trim()) {
						func = "";
						th.addClass("not-used");
					} else {
						let label = func.trim();
						if (label.substring(0, 2) == "/*") {
							label = label.substring(2).split("*/")[0].trim();
						}
						th.addClass("used").attr({ title: label });
					}
					th.data({
							"name": "setting.command.fn['" + key + "']"
						,	"key" : key
						,	"func": func
					});
				}
				const tr = $("<tr>").addClass("key-" + (keyName=='`' ? '-' : keyName)).append(th);
				for (let j = 0; j < withs.length; j++) {
					const w = withs[j];
					const td = $("<td>");
					if (oSmiEditor[w].reserved.indexOf(key) >= 0) {
						let func = oSmiEditor[w][key];
						let label = func;
						if (label) {
							let type = typeof label;
							if (type == "string") {
								label = label.trim();
								if (label.substring(0, 2) == "/*") {
									label = label.substring(2).split("*/")[0].trim();
								}
							} else if (type == "function") {
								label = label.name;
							}
						} else {
							label = "시스템 단축키";
						}
						label = "예약: " + label;
						td.addClass("fixed").text(label);
					} else {
						let func = setting.command[w][key];
						if (!func || !func.trim()) {
							func = "";
						} else {
							let label = func.trim();
							if (label.substring(0, 2) == "/*") {
								label = label.substring(2).split("*/")[0].trim();
							}
							td.addClass("used").text(label);
						}
						td.data({
								"name": "setting.command." + w + "['" + key + "']"
							,	"with": j
							,	"key" : key
							,	"func": func
						});
					}
					tr.append(td);
				}
				tbody.append(tr);
			}
		})();
		
		tableCommand.on("click", "th.used, th.not-used, td:not(.fixed)", function() {
			const data = $(this).data();
			const keyCode = data.key.charCodeAt();
			let keyName = (111 < keyCode && keyCode < 192) 
			            ? ("F" + (keyCode - 111))
			            : data.key;
			switch (data.with) {
				case 0: {
					keyName = "Ctrl + " + keyName;
					break;
				}
				case 1: {
					keyName = "Alt + " + keyName;
					break;
				}
				case 2: {
					keyName = "Ctrl + Alt + " + keyName;
					break;
				}
				case 3: {
					keyName = "Ctrl + Shift + " + keyName;
					break;
				}
			}
			
			if (inputCommandKey.val() == keyName) {
				// 현재 작업 중인 것
				return;
			}
			checkSaved("cmd", () => {
				setSaved("cmd", true);
				inputCommandName.val(data.name);
				inputCommandKey .val(keyName);
				inputCommandFunc.val(data.func);
			});
		});

		inputCommandKey.on("keydown", function(e) {
			e.preventDefault();
			
			let name = "";
			let key = String.fromCharCode(e.keyCode);
			let func = "";
			if (e.keyCode == 192) {
				key = '`';
			}
			
			if (keys.indexOf(key) >= 0) {
				let keyName = (111 < e.keyCode && e.keyCode < 192)
				            ? ("F" + (e.keyCode - 111))
				            : key;
				const keyIndex = keyNames.indexOf(keyName);
				const selector = "tr.key-" + (keyName == '`' ? '-' : keyName);
				
				let w = null;
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							if (oSmiEditor.withCtrlShifts.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + Shift + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(3)").data("func");
								name = "setting.command.withCtrlShifts[\"" + key + "\"]";
								keyName = "Ctrl + Shift + " + keyName;
							}
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							if (oSmiEditor.withCtrlAlts.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + Alt + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(2)").data("func");
								name = "setting.command.withCtrlAlts[\"" + key + "\"]";
								keyName = "Ctrl + Alt + " + keyName;
							}
						} else {
							if (oSmiEditor.withCtrls.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(0)").data("func");
								name = "setting.command.withCtrls[\"" + key + "\"]";
								keyName = "Ctrl + " + keyName;
							}
						}
					} else {
						if (e.altKey) {
							if (oSmiEditor.withAlts.reserved.indexOf(key) >= 0) {
								keyName = "Alt + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(1)").data("func");
								name = "setting.command.withAlts[\"" + key + "\"]";
								keyName = "Alt + " + keyName;
							}
						} else {
							func = tableCommand.find(selector + " > th:eq(0)").data("func");
							name = "setting.fn[\"" + key + "\"]";
						}
					}
				}

				if (inputCommandKey.val() == keyName) {
					// 현재 작업 중인 것
					return;
				}
				$("#areaTableCommand").scrollTop(keyIndex * 20);
				checkSaved("cmd", () => {
					inputCommandName.val(name);
					inputCommandKey .val(keyName);
					inputCommandFunc.val(func);
				});
				
			} else {
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							key = "Ctrl + Shift + ";
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							key = "Ctrl + Alt + ";
						} else {
							key = "Ctrl + ";
						}
					} else {
						if (e.altKey) {
							key = "Alt + ";
						} else {
							
						}
					}
				}
			}
		});
		
		inputCommandFunc.bind("input propertychange", function() {
			if (inputCommandKey.val().length > 1) { // 한 글자인 경우 단축키 조합 아님
				setSaved("cmd", false);
			} else {
				// 입력 차단
				inputCommandFunc.val("");
			}
		});

		$("#areaFunctions").on("click", "li", function() {
			const func = inputCommandFunc.val();
			inputCommandFunc.val((func ? func + "\n" : "") + $(this).data("input"));
			if (inputCommandName.val()) {
				setSaved("cmd", false);
			}
		});

		submitFuncs["cmd"] = () => {
			const name = inputCommandName.val();
			if (name) {
				let func = inputCommandFunc.val();
				if (func.trim().length == 0) {
					func = " ";
				}
				eval(name + " = func;");
				setSaved("cmd", true);
				refreshTableCommand();
				opener.setSetting(setting);
				opener.saveSetting();
			}
		};
	}
	
	{	// 자동완성
		(refreshFuncs["ac"] = (setting) => {
			refresh($("#ac"), setting);
			setSaved("ac", (JSON.stringify(setting.autoComplete) == JSON.stringify(opener.setting.autoComplete)));
		})(setting);
	
		submitFuncs["ac"] = () => {
			$("#ac").find("textarea").each((_, el) => {
				const textarea = $(el);
				const name = "setting['" + textarea.attr("name").split("_").join("']['") + "']";
				let value = textarea.val();
				if (value) {
					value = value.split("\n");
				} else {
					value = [];
				}
				eval(name + " = value");
			});
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 자동치환
		saved.replace = { status: true, name: "자동치환 설정" };
	
		const replaceList = $("#replaceList");
	
		function appendReplace(item) {
			if (!item) {
				item = { from: "", to: "", use: true };
			}
			replaceList.append(
				$("<li>")
					.append($("<input type='text' name='from'>").val(item.from))
					.append("→")
					.append($("<input type='text' name='to'>"  ).val(item.to))
					.append($("<input type='checkbox' name='use'>").prop("checked", item.use))
					.append($("<button type='button' class='prev'>").text("∧"))
					.append($("<button type='button' class='next'>").text("∨"))
					.append($("<button type='button' class='remove'>").text("✕"))
			);
		}
		(refreshFuncs["replace"] = (setting) => {
			refresh($("#replace"), setting);
			replaceList.empty();
			for (let i = 0; i < setting.replace.length; i++) {
				appendReplace(setting.replace[i]);
			}
			setSaved("replace"
				,  (setting.saveWithNormalize == opener.setting.saveWithNormalize)
				&& (JSON.stringify(setting.command) == JSON.stringify(opener.setting.command))
			);
		})(setting);
		
		$("#replace > .add-replace").on("click", function() {
			appendReplace();
			setSaved("replace", false);
		});

		replaceList.on("click", "li > button.prev", function() {
			const li = $(this).parent();
			const prev = li.prev();
			if (prev.length) {
				prev.before(li);
				setSaved("replace", false);
			}
		});
		replaceList.on("click", "li > button.next", function() {
			const li = $(this).parent();
			const next = li.next();
			if (next.length) {
				next.after(li);
				setSaved("replace", false);
			}
		});
		replaceList.on("click", "li > button.remove", function() {
			const li = $(this).parent();
			confirm("삭제하시겠습니까?", function() {
				li.remove();
				setSaved("replace", false);
			});
		});
		
		submitFuncs["replace"] = () => {
			const replaces = [];
			
			replaceList.find("li").each((_, el) => {
				const li = $(el);
				const item = {
						from: li.find("input[name=from]").val()
					,	to  : li.find("input[name=to]").val()
					,	use : li.find("input[name=use]").prop("checked")
				};
				if (item.from && item.to) {
					replaces.push(item);
				}
			});

			setting.saveWithNormalize = $("input[name=saveWithNormalize]").prop("checked");
			setting.replace = replaces;
			setSaved("replace", true);
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 스타일
		saved.style = { status: true, name: "스타일 설정" };
		
		const presetUl = $("#style_color_preset ul");
		presetUl.on("click", "li span", function() {
			const color = setting.colorPreset[$(this).parent().data("key")];
			for (let name in color) {
				$("input[name=color_" + name + "]").val(color[name]);
			}
		}).on("click", "li button", function() {
			const key = $(this).parent().data("key");
			confirm("삭제하시겠습니까?", () => {
				delete(setting.colorPreset[key]);
				refreshPreset(setting);
			});
		});
		$("#btnAddPreset").on("click", () => {
			const name = prompt("프리셋 이름을 입력하세요.");
			if (!name) {
				alert("이름이 입력되지 않았습니다.");
			}
			const color = {};
			color.background = $("input[name=color_background]").val();
			color.selector   = $("input[name=color_selector]"  ).val();
			color.border     = $("input[name=color_border]"    ).val();
			color.tab        = $("input[name=color_tab]"       ).val();
			color.tabBorder  = $("input[name=color_tabBorder]" ).val();
			color.editor     = $("input[name=color_editor]"    ).val();
			color.text       = $("input[name=color_text]"      ).val();
			color.hover      = $("input[name=color_hover]"     ).val();
			color.notSaved   = $("input[name=color_notSaved]"  ).val();
			color.syncBorder = $("input[name=color_syncBorder]").val();
			color.syncError  = $("input[name=color_syncError]" ).val();
			color.syncEqual  = $("input[name=color_syncEqual]" ).val();
			setting.colorPreset[name] = color;
			refreshPreset(setting);
		});
		function refreshPreset(setting) {
			presetUl.empty();
			for (let key in setting.colorPreset) {
				const li = $("<li>").data({ key: key });
				li.append($("<span>").text(key)).append($("<button>").attr({ type: "button" }).text("×"));
				presetUl.append(li);
			}
		}
		
		function refreshHighlight() {
			SmiEditor.setHighlight({
					parser: $("select[name=highlight_parser]").val()
				,	style : $("select[name=highlight_style]").val()
				,	enter : $("input[name=highlight_enter]").prop("checked")
				,	color : $("input[name=highlight_color]").prop("checked")
				,	sync  : Number($("input[name=highlight_sync]").val())
			}, [editorNewFile]);
		}
		const editorNewFile = new SmiEditor();
		const labelNewFile = $("#areaNewFile").append(editorNewFile.area.height(400));
		{	// textarea resize
			let resizeNewFile = false;
			editorNewFile.input.attr({ name: "newFile" }).height(398).on("mousedown", function() {
				resizeNewFile = true;
			});
			$(document).on("mousemove", function() {
				editorNewFile.area.height(editorNewFile.input.outerHeight());
			}).on("mouseup", function() {
				resizeNewFile = false;
			});
		}
		
		(refreshFuncs["style"] = (setting) => {
			refresh($("#style"), setting);
			refreshPreset(setting);
			setSaved("style"
				,  (setting.useTab == opener.setting.useTab)
				&& (setting.viewer.useAlign == opener.setting.viewer.useAlign)
				&& (JSON.stringify(setting.highlight  ) == JSON.stringify(opener.setting.highlight  ))
				&& (JSON.stringify(setting.color      ) == JSON.stringify(opener.setting.color      ))
				&& (JSON.stringify(setting.colorPreset) == JSON.stringify(opener.setting.colorPreset))
				&& (JSON.stringify(setting.newFile    ) == JSON.stringify(opener.setting.newFile    ))
				&& (JSON.stringify(setting.viewer.css ) == JSON.stringify(opener.setting.viewer.css ))
			);
			editorNewFile.render();
			refreshHighlight();
		})(setting);

		let selectParser = $("select[name=highlight_parser]");
		let selectStyle  = $("select[name=highlight_style]" );
		let selectSize   = $("select[name=size]");
		if (opener.highlights) {
			for (let i = 0; i < opener.highlights.length; i++) {
				const item = opener.highlights[i].trim();
				if (item.length) {
					const split = item.split(":");
					const value = split[0].trim();
					let name = (split.length > 1) ? split[1].trim() : value;
					if (name.indexOf("?")) name = name.split("?")[0];
					selectStyle.append($("<option>").val(value).text(name));
				}
			}
			selectParser.find("option[value='" + setting.highlight.parser + "']").prop("selected", true);
			selectStyle .find("option[value='" + setting.highlight.style  + "']").prop("selected", true);
		}
		$([	"select[name=highlight_parser]"
		,	"select[name=highlight_style]"
		,	"input[name=highlight_enter]"
		,	"input[name=highlight_color]"].join(",")).on("change", function() {
			refreshHighlight();
		});
		selectParser.on("change", function() {
			if (selectParser.val()) {
				$("#style_highlight_setting").removeClass("disabled").find("input, select[name=highlight_style]").attr({ disabled: false });
			} else {
				$("#style_highlight_setting").addClass   ("disabled").find("input, select[name=highlight_style]").attr({ disabled: true  });
			}
		}).change();
		
		selectSize.find("option[value='" + selectSize.data("value") + "']").prop("selected", true);
		
		$("#style").on("input propertychange", function() {
			setSaved("style", false);
		});
		
		submitFuncs["style"] = () => {
			setting.size             = $("select[name=size]").val();
			setting.useTab           = $("input[name=useTab]").prop("checked");
			setting.highlight.parser = $("select[name=highlight_parser]").val();
			setting.highlight.style  = $("select[name=highlight_style]").val();
			setting.highlight.enter  = $("input[name=highlight_enter]").prop("checked");
			setting.highlight.color  = $("input[name=highlight_color]").prop("checked");
			setting.highlight.sync   = Number($("input[name=highlight_sync]").val());
			setting.viewer.useAlign  = $("input[name=viewer_useAlign]").prop("checked");
			setting.viewer.size      = $("input[name=viewer_size]").val();
			setting.viewer.css       = $("textarea[name=viewer_css]").val();
			setting.newFile          = $("textarea[name=newFile]"   ).val();
			setting.color.background = $("input[name=color_background]").val();
			setting.color.selector   = $("input[name=color_selector]"  ).val();
			setting.color.border     = $("input[name=color_border]"    ).val();
			setting.color.tab        = $("input[name=color_tab]"       ).val();
			setting.color.tabBorder  = $("input[name=color_tabBorder]" ).val();
			setting.color.editor     = $("input[name=color_editor]"    ).val();
			setting.color.text       = $("input[name=color_text]"      ).val();
			setting.color.hover      = $("input[name=color_hover]"     ).val();
			setting.color.notSaved   = $("input[name=color_notSaved]"  ).val();
			setting.color.syncBorder = $("input[name=color_syncBorder]").val();
			setting.color.syncError  = $("input[name=color_syncError]" ).val();
			setting.color.syncEqual  = $("input[name=color_syncEqual]" ).val();
			refreshHighlight();
			setSaved("style", true);
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 플레이어
		(refreshFuncs["player"] = (setting) => {
			refresh($("#player"), setting);
			setSaved("player"
				,  (setting.exts == opener.setting.exts)
				&& (JSON.stringify(setting.player.control) == JSON.stringify(opener.setting.player.control))
			);
		})(setting);
	
		const select = $("select[name=player_control_dll]");
		if (opener.playerDlls) {
			for (let i = 0; i < opener.playerDlls.length; i++) {
				const dll = opener.playerDlls[i].split(":");
				select.append($("<option>").val(dll[0].trim()).text(dll[1].trim()));
			}
			select.find("option[value='" + select.data("value") + "']").prop("selected", true);
		}
		select.on("change", function() {
			const dll = select.val();
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = {
						path: ""
					,	withRun: true
					,	withExit: true
				};
			}
			$("input[name=player_control_what_path]"    ).val(dllSetting.path);
			$("input[name=player_control_what_withRun]" ).prop("checked", dllSetting.withRun);
			$("input[name=player_control_what_withExit]").prop("checked", dllSetting.withExit);
		});
	
		$("#btnPlayerPath").on("click", function() {
			opener.binder.selectPlayerPath();
		});
		opener.afterSelectPlayerPath = (path) => {
			$("input[name=player_control_what_path]").val(path);
		};

		submitFuncs["player"] = () => {
			setting.player.exts = $("input[name=player_exts]").val();
			const dll = setting.player.control.dll = select.val();
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = setting.player.control[dll] = {};
			}
			dllSetting.path     = $("input[name=player_control_what_path]"    ).val();
			dllSetting.auto     = $("input[name=player_control_what_auto]"    ).prop("checked");
			dllSetting.withRun  = $("input[name=player_control_what_withRun]" ).prop("checked");
			dllSetting.withExit = $("input[name=player_control_what_withExit]").prop("checked");
			opener.setSetting(setting);
			opener.saveSetting();
			opener.binder.setVideoExts(setting.player.exts);
		};
	}
	
	{	// 메뉴
		saved.menu = { status: true, name: "메뉴 설정" };
	
		const menuList = $("#menuList");
	
		function appendMenu(menus) {
			if (!menus) menus = [""];
			
			const fieldset = $("<fieldset>");
			const legend = $("<legend>")
				.append($("<input type='text'>").val(menus[0]))
				.append($("<button type='button' class='prev'>").text("∧"))
				.append($("<button type='button' class='next'>").text("∨"))
				.append($("<button type='button' class='remove'>").text("✕"));
			fieldset.append(legend);
			
			const ol = $("<ol>");
			fieldset.append(ol);
			
			for (let j = 1; j < menus.length; j++) {
				const menu = menus[j];
				const div = menu.indexOf("|");
				const name = (div > 0) ? menu.substring(0, div) : menu;
				const func = (div > 0) ? menu.substring(div + 1) : "";
				appendSubMenu(ol, name, func);
			}
			
			fieldset.append($("<button type='button' class='add-menu'>").text("추가"));
			
			menuList.append($("<li>").append(fieldset));
		}
		function appendSubMenu(ol, name, func) {
			if (!ol) return;
			if (!name) name = "";
			if (!func) func = "";
			ol.append(
				$("<li>")
					.append($("<input type='text'>").val(name))
					.append($("<button type='button' class='prev'>").text("∧"))
					.append($("<button type='button' class='next'>").text("∨"))
					.append($("<input type='text' class='menu-func'>").val(func))
					.append($("<button type='button' class='remove'>").text("✕"))
			);
		}
		(refreshFuncs["menu"] = (setting) => {
			menuList.empty();
			for (let i = 0; i < setting.menu.length; i++) {
				appendMenu(setting.menu[i]);
			}
			setSaved("menu", (JSON.stringify(setting.menu) == JSON.stringify(opener.setting.menu)));
		})(setting);
		
		$("#menu > .add-menu").on("click", function() {
			appendMenu();
			setSaved("menu", false);
		});
		
		menuList.on("click", ".add-menu", function() {
			appendSubMenu($(this).parent().find("ol"));
			setSaved("menu", false);
		});

		menuList.on("click", "legend > button.prev", function() {
			const menu = $(this).parents("li");
			const prev = menu.prev();
			if (prev.length) {
				prev.before(menu);
				setSaved("menu", false);
			}
		});
		menuList.on("click", "legend > button.next", function() {
			const menu = $(this).parents("li");
			const next = menu.next();
			if (next.length) {
				next.after(menu);
				setSaved("menu", false);
			}
		});
		menuList.on("click", "legend > button.remove", function() {
			const menu = $(this).parents("li");
			confirm("삭제하시겠습니까?", () => {
				menu.remove();
				setSaved("menu", false);
			});
		});
		
		menuList.on("click", "ol > li > button.prev", function() {
			const subMenu = $(this).parent();
			const prev = subMenu.prev();
			if (prev.length) {
				prev.before(subMenu);
				setSaved("menu", false);
			}
		});
		menuList.on("click", "ol > li > button.next", function() {
			const subMenu = $(this).parent();
			const next = subMenu.next();
			if (next.length) {
				next.after(subMenu);
				setSaved("menu", false);
			}
		});
		menuList.on("click", "ol > li > button.remove", function() {
			const subMenu = $(this).parent();
			confirm("삭제하시겠습니까?", () => {
				subMenu.remove();
				setSaved("menu", false);
			});
		});
		
		submitFuncs["menu"] = () => {
			const menus = [];
			
			menuList.find("fieldset").each((_, el) => {
				const fieldset = $(el);
				const menu = [fieldset.find("legend > input").val()];
				
				fieldset.find("li").each((_, el) => {
					const inputs = $(el).find("input");
					menu.push(inputs[0].value + "|" + inputs[1].value);
				});
				menus.push(menu);
			});
			
			setting.menu = menus;
			setSaved("menu", true);
			opener.setSetting(setting);
			opener.saveSetting();
			
			// Alt 단축키 바뀌었을 수 있으므로 단축키 설정 새로고침
			refreshTableCommand();
		};
	}
	
	$("#btnLoadSetting").on("click", function() {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(setting);
		}
	});
	
	$("#btnLoadDefault").on("click", function() {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(opener.DEFAULT_SETTING);
		}
	});
	
	$("#btnSubmit").on("click", function() {
		const submitFunc = submitFuncs[opened];
		if (submitFunc) submitFunc();
	});

	$("form").each((_, el) => {
		const form = $(el);
		form.attr("onsubmit", "submitFuncs['" + form.attr("id") + "'](); return false;");
		form.append($("<button type='submit'>").hide());
	});
	
	show(opener.setting.show ? opener.setting.show : 0);
});
</script>
<style>
* {
	font-size: 14px;
}
body {
	background: #f0f0f0;
}
textarea {
	width: 100%;
	height: 100px;
	font-family: '돋움체'; /* 여기선 고정폭 문자 써야 할 듯 */
	resize: vertical;
}

input[type=number] { width: 50px; }

fieldset {
	border-color: #888;
	padding: 8px;
	margin: 8px 0;
}

fieldset li { margin-bottom: 2px; }

/* 기본 틀 */
#settingNav {
	position: fixed;
	top: 0;
	left: 8px;
	right: 8px;
	height: 40px;
	padding-top: 8px;
	border-bottom: 1px solid #888;
}
#settingArea {
	position: fixed;
	top: 40px;
	left: 8px;
	right: 8px;
	bottom: 48px;
	overflow-y: scroll;
	background: #f8f8f8;
	border: 1px solid #888;
	border-top: 0;
	padding: 8px;
}
#applyArea {
	position: fixed;
	left: 0;
	right: 0;
	bottom: 0;
	height: 48px;
}
#btnLoadSetting,
#btnLoadDefault,
#btnSubmit {
	float: right;
	margin: 8px 8px 8px 0;
	min-width: 100px;
	padding: 4px;
	line-height: 22px;
	font-size: 16px;
}

/* 탭 UI */
#settingNav > a {
	display: block;
	float: left;
	margin: 0 -1px -1px 0;
	border: 1px solid #888;
	border-radius: 6px 6px 0 0;
	background: #eee;
	color: #000;
	font-size: 16px;
	text-decoration: none;
	height: 32px;
	line-height: 32px;
	padding: 0 8px;
}
#settingNav > a.selected {
	background: #f8f8f8;
	border-bottom-color: #f8f8f8;
}
#settingNav > a:hover {
	background: #f8f8f8;
}
#settingArea > form {
	display: none;
}
#settingArea > form.selected {
	display: block;
}

/* 창 */
#btnGetWindows {
	padding: 4px;
}
#fieldWindow {
	width: 100%;
	height: calc(100% - 50px);
	position: relative;
}
#fieldWindow > fieldset {
	position: absolute;
}
#fieldWindow > fieldset:hover {
	z-index: 9999;
	background: #f8f8f8;
}
#fieldWindow > fieldset span {
	display: inline-block;
	width: 16px;
	text-align: center;
}

/* 단축키 */
#areaTableCommand {
	height: 210px;
	overflow-y: scroll;
	border-bottom: 1px solid #aaa;
	margin-bottom: 4px;
}
#tableCommand {
	width: 100%;
}
#tableCommand tr {
	height: 20px;
}
#tableCommand th {
	background: #e1e1e1;
}
#tableCommand th.not-used {
	background: #fff;
}
#tableCommand th.used,
#tableCommand th.not-used {
	cursor: pointer;
}
#tableCommand td {
	height: 20px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	cursor: pointer;
}
#tableCommand th.not-used:hover,
#tableCommand td:hover {
	background: #ff8;
}
#tableCommand td.fixed {
	background: #f88;
	cursor: default;
}
#tableCommand th.used,
#tableCommand td.used {
	background: #8ff;
}
#tableCommand th.used:hover,
#tableCommand td.used:hover {
	background: #cfc;
}
#areaFunctions li {
	margin: 8px 0;
	border: 1px solid #ddd;
	border-radius: 8px;
	padding: 4px;
	cursor: pointer;
}
#areaFunctions li:hover {
	background: #ffd;
}
#areaFunctions h4 {
	margin-bottom: 4px;
}

/* 자동치환, 메뉴 */
#replaceList { margin: 8px 0 2px; }
#replaceList input[type=text] { width: calc(50% - 40px); }
#replaceList input[type=checkbox] { width: 17px; }
#replace > button.add-replace { width: 100%; margin-top: 8px; }

#replaceList button,
#menu button { width: 16px; }
#menu input,
#menu button.add-menu { width: 200px; }
#menu input.menu-func { width: calc(100% - 250px); margin-left: 2px; }
#menu > button.add-menu { width: 216px; margin-top: 8px; }

#replaceList button,
fieldset legend button,
fieldset ol button,
#btnPlayerPath { border-left-width: 0; }
#replace input + button { border-left-width: 1px; }

/* 스타일 */
#style_highlight_setting > div {
	float: left;
	margin-right: 4px;
}
#style_highlight_setting:after {
	display: block;
	content: ""; 
	clear: both;
	margin-bottom: 8px;
}
#style_highlight_setting label {
	margin-right: 8px;
}
#style_highlight_setting.disabled label > span {
	opacity: 0.5;
}
#style_highlight_setting select[name=highlight_parser],
#style_highlight_setting input[name=highlight_sync] {
	width: 101px;
}
#style_color_preset {
	float: left;
	width: 200px;
	height: 146px;
}
#style_color_preset ul {
	overflow-y: scroll;
	height: calc(100% - 18px);
}
#style_color_preset li {
	border: 1px solid #888;
	cursor: pointer;
	width: 100%;
	height: 20px;
	line-height: 20px;
}
#style_color_preset li:hover {
	background: #fff;
}
#style_color_preset li span {
	display: block;
	width: calc(100% - 16px);
	height: 18px;
	float: left;
	white-space: nowrap;
	overflow: hidden;
}
#style_color_preset li button {
	display: block;
	width: 16px;
	height: 18px;
	float: right;
	border-width: 0 0 0 1px;
}
#btnAddPreset {
	width: 100%;
}
#style_color_setting {
	float: left;
}
#style_color_setting label {
	display: inline-block;
	margin-left: 10px;
}
#style_color_setting span {
	display: inline-block;
	width: 140px;
}
#style_color:after {
	display: block;
	content: "";
	clear: both;
}
/* 새 문서 에디터 */
#areaNewFile .hold > .col-sync {
	display: none;
}
#areaNewFile .hold > .input {
	left: 0;
}
#areaNewFile .highlight-textarea {
	border: 1px solid #888;
}
#areaNewFile .highlight-textarea > textarea {
	resize: vertical;
}
</style>
</head>
<body>

<nav id="settingNav">
	<a href="javascript:show(0)">창 배치</a>
	<a href="javascript:show(1)">싱크</a>
	<a href="javascript:show(2)">단축키</a>
	<a href="javascript:show(3)">자동완성</a>
	<a href="javascript:show(4)">자동치환</a>
	<a href="javascript:show(5)">스타일</a>
	<a href="javascript:show(6)">플레이어</a>
	<a href="javascript:show(7)">메뉴</a>
</nav>
<div id="settingArea">
	<form id="window" style="height: 100%;">
		<div>
			<button type="button" id="btnGetWindows">현재 위치 가져오기</button>
			<label><input type="checkbox" name="window_follow" /> 창 함께 이동</label>
		</div>
		<div id="fieldWindow">
			<fieldset id="fieldEditor">
				<legend>에디터</legend>
				<label><span>↦</span>: <input type="number" name="window_x" /></label>
				<label><span>↧</span>: <input type="number" name="window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="window_width" /></label>
				<label><span>↕</span>: <input type="number" name="window_height" /></label>
			</fieldset>
			<fieldset id="fieldViewer">
				<legend>미리보기</legend>
				<label><span>↦</span>: <input type="number" name="viewer_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="viewer_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="viewer_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="viewer_window_height" /></label>
			</fieldset>
			<fieldset id="fieldPlayer">
				<legend>플레이어</legend>
				<label><span>↦</span>: <input type="number" name="player_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="player_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="player_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="player_window_height" /></label>
				<br />
				<label><input type="checkbox" name="player_window_use" /> 위치 고정 사용</label>
			</fieldset>
		</div>
	</form>
	
	<form id="sync">
		<label>싱크 입력 시 <input type="number" name="sync_insert" />줄 아래로 이동</label><br />
		<label>싱크 수정 시 <input type="number" name="sync_update" />줄 아래로 이동</label><br />
		<label>싱크 가중치: <input type="number" name="sync_weight" />ms</label><br />
		<label>싱크 조절 단위: <input type="number" name="sync_unit" />ms</label><br />
		<label>재생 이동 단위: <input type="number" name="sync_move" />ms</label><br />
		<label>싱크 언어: <input type="text" name="sync_lang" /></label><br />
		<label>싱크 태그 형태: <input type="text" name="sync_preset" style="width: 400px;" /></label><br />
		<br />
		<label><input type="checkbox" name="sync_frame" /> 프레임 단위 싱크 보정</label><br />
		<p>※ 프레임 정보를 가져오지 못했을 경우 FPS를 기준으로 프레임 단위 싱크로 보정이 들어갑니다.<br />
			　가변 프레임 영상의 경우 문제가 생길 수 있습니다.
		</p>
		<br />
		<label>키프레임을 신뢰할 수 있는 영상에 대해 <input type="number" name="sync_kLimit" />ms 범위에서 화면 싱크를 키프레임에 맞도록 보정</label><br />
		<label><input type="checkbox" name="sync_kframe" /> 키프레임을 신뢰할 수 있는 영상에 대해 자동으로 화면 싱크 처리</label><br />
		<br />
		<label><input type="checkbox" name="sync_holds" /> 싱크 일괄 이동 시 다른 홀드에도 적용</label><br />
		<p>※ 블록지정 영역에 대한 일괄 싱크 입력에는 적용되지 않습니다.</p>
	</form>
	
	<form id="cmd">
		<table style="width: calc(100% - 17px);">
			<cols>
				<col style="width: 8%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
			</cols>
			<thead>
				<tr>
					<th></th>
					<th>Ctrl</th>
					<th>Alt</th>
					<th>Ctrl+Alt</th>
					<th>Ctrl+Shift</th>
				</tr>
			</thead>
		</table>
		<div id="areaTableCommand">
			<table id="tableCommand">
				<cols>
					<col style="width: 8%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
				</cols>
				<tbody></tbody>
			</table>
		</div>
		<input type="hidden" id="inputCommandName" />
		<label>조합 <input type="text" id="inputCommandKey" readonly style="width: 100px;" /> (← 여기를 선택한 상태에서 단축키를 입력할 수 있습니다.)</label>
		<br />
		<textarea id="inputCommandFunc" spellcheck="false"></textarea>
		
		<fieldset id="areaFunctions" style="height: 364px; overflow-y: scroll;">
			<legend>사용자 정의 명령 함수 지원</legend>
			<ul>
				<li data-input="editor.getText()">
					<h4>editor.getText() → { text: '전체_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>전체 내용을 구해옵니다.</p>
				</li>
				<li data-input="editor.setText(text, [cursor, cursor])">
					<h4>editor.setText(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>전체 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.getLine()">
					<h4>editor.getLine() → { text: '현재_줄_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>커서(끝) 줄의 내용을 가져옵니다.</p>
				</li>
				<li data-input="editor.setLine(text, [cursor, cursor])">
					<h4>editor.setLine(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>커서(끝) 줄의 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.inputText(text, false)">
					<h4>editor.inputText(string '입력_텍스트', bool '커서_고정')</h4>
					<p>현재 커서 위치에 내용을 입력합니다.</p>
				</li> 
				<li data-input="editor.tagging('<i>', false)">
					<h4>editor.tagging(string '&lt;태그&gt;', bool '커서_위치부터')</h4>
					<p>커서가 있는 줄 전체, 혹은 커서 위치 이후 문자열에 태그를 입힙니다.</p>
				</li>
				<li data-input="editor.taggingRange('<u>')">
					<h4>editor.taggingRange(tag) { self.taggingRange(tag); };</h4>
					<p>tagging(string '&lt;태그&gt;', true)와 같은 동작입니다.</p>
				</li>
				<li data-input="editor.moveToSync()">
					<h4>editor.moveToSync()</h4>
					<p>현재 대사의 싱크를 재생합니다.<br />
						괄호 안에 가중치를 넣을 수 있습니다.
					</p>
				</li>
				<li data-input="editor.findSync()">
					<h4>editor.findSync()</h4>
					<p>현재 재생 중인 대사를 찾습니다.</p>
				</li>
				<li data-input="editor.deleteLine()">
					<h4>editor.deleteLine()</h4>
					<p>현재 줄을 삭제합니다.</p>
				</li>
				<li data-input="editor.insertSync()">
					<h4>editor.insertSync()</h4>
					<p>싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.insertSync(true)">
					<h4>editor.insertSync(true)</h4>
					<p>화면 싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.toggleSyncType()">
					<h4>editor.toggleSyncType()</h4>
					<p>기본 싱크 ↔ 화면 싱크 토글</p>
				</li>
				<li data-input="editor.removeSync()">
					<h4>editor.removeSync()</h4>
					<p>선택 영역 싱크를 삭제합니다.</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.playOrPause()">
					<h4>SmiEditor.PlayerAPI.playOrPause()</h4>
					<p>재생/일시정지</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.play()">
					<h4>SmiEditor.PlayerAPI.play()</h4>
					<p>재생</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.stop()">
					<h4>SmiEditor.PlayerAPI.stop()</h4>
					<p>정지</p>
				</li>
				<li data-input="newFile()">
					<h4>newFile()</h4>
					<p>새 파일</p>
				</li>
				<li data-input="openFile()">
					<h4>openFile()</h4>
					<p>파일 열기</p>
				</li>
				<li data-input="saveFile()">
					<h4>saveFile()</h4>
					<p>파일 저장하기</p>
				</li>
				<li data-input="saveFile(true)">
					<h4>saveFile(true)</h4>
					<p>다른 이름으로 저장하기</p>
				</li>
				<li data-input="openSetting()">
					<h4>openSetting()</h4>
					<p>설정창 열기</p>
				</li>
				<li data-input="openAddon('~~.html')">
					<h4>openAddon("~~.html")</h4>
					<p>직접 만든 부가기능 창을 열 수 있습니다.</p>
				</li>
			</ul>
		</fieldset>
	</form>
	
	<form id="ac">
		<p>
			줄 단위로 자동완성 문자열을 설정할 수 있습니다.<br />
			'|'를 이용해 입력값과 출력값이 다르게 설정할 수 있습니다. 
		</p>
		<br />
		<label>일반 문자열 (단어 입력 중 Tab키 혹은 Ctrl+스페이스바)
			<textarea name="autoComplete_0_1"  spellcheck="false"></textarea>
		</label>
		<label>@
			<textarea name="autoComplete_50_1"  spellcheck="false"></textarea>
		</label>
		<label>#
			<textarea name="autoComplete_51_1"  spellcheck="false"></textarea>
		</label>
		<label>$
			<textarea name="autoComplete_52_1"  spellcheck="false"></textarea>
		</label>
		<label>%
			<textarea name="autoComplete_53_1"  spellcheck="false"></textarea>
		</label>
		<label>^
			<textarea name="autoComplete_54_1"  spellcheck="false"></textarea>
		</label>
		<label>&
			<textarea name="autoComplete_55_1"  spellcheck="false"></textarea>
		</label>
		<label>(
			<textarea name="autoComplete_57_1"  spellcheck="false"></textarea>
		</label>
		<label>)
			<textarea name="autoComplete_48_1"  spellcheck="false"></textarea>
		</label>
		<label>&lt;
			<textarea name="autoComplete_188_1" spellcheck="false"></textarea>
		</label>
		<label>&gt;
			<textarea name="autoComplete_190_1" spellcheck="false"></textarea>
		</label>
	</form>
	
	<form id="replace">
		<p>
			자막 파일 저장 시 자동치환 동작 설정입니다. 
		</p>
		<label><input type="checkbox" name="saveWithNormalize" /> 특수태그 정규화 자동 적용</label><br />
		<ol id="replaceList"></ol>
		<button type="button" class="add-replace">추가</button>
	</form>
	
	<form id="style">
		<div id="style_highlight_setting">
			<div>
				<label>문법 하이라이트:
					<select name="highlight_parser">
						<option value="">사용 안 함</option>
						<option value="SyncOnly">싱크만 구분</option>
						<option value="withoutSync">싱크 제외</option>
						<option value="full">전체</option>
					</select>
				</label><br />
				<label class="for-withoutSync"><span >　　싱크 투명도:</span>
					<input type="range" name="highlight_sync" min="0" max="1" step="0.01" />
				</label>
			</div>
			<div>
				<select name="highlight_style"></select><br />
				<span>
					<label><input type="checkbox" name="highlight_enter" /> <span>줄바꿈 표시</span></label>
					<label><input type="checkbox" name="highlight_color" /> <span>색상 미리보기</span></label>
				</span>
			</div>
		</div>
		<label>UI 배율
			<select name="size">
				<option value="0.8" >80%</option>
				<option value="0.9" >90%</option>
				<option value="1"  >100%</option>
				<option value="1.1">110%</option>
				<option value="1.2">120%</option>
				<option value="1.3">130%</option>
				<option value="1.4">140%</option>
				<option value="1.5">150%</option>
				<option value="1.7">170%</option>
				<option value="2.0">200%</option>
				<option value="2.5">250%</option>
				<option value="3.0">300%</option>
				<option value="4.0">400%</option>
			</select>
			<br />
		</label>
		<label><input type="checkbox" name="useTab" /> 탭 사용</label><br />
		<label><input type="checkbox" name="viewer_useAlign" /> 미리보기 줄표로 시작할 경우 왼쪽 정렬</label><br />
		<fieldset id="style_color">
			<legend>색 설정</legend>
			<fieldset id="style_color_preset">
				<legend>프리셋</legend>
				<ul></ul>
				<button type="button" id="btnAddPreset">현재값 프리셋에 추가</button>
			</fieldset>
			<div id="style_color_setting">
				<label><span>기본 배경 색      </span><input type="color" name="color_background" /></label><label><span>저장되지 않음 표시</span><input type="color" name="color_notSaved"   /></label><br />
				<label><span>탭/홀드 배경 색   </span><input type="color" name="color_selector"   /></label><label><span>설정/탭 테두리    </span><input type="color" name="color_tabBorder"  /></label><br />
				<label><span>비활성 탭/홀드 색 </span><input type="color" name="color_tab"        /></label><label><span>홀드/에디터 테두리</span><input type="color" name="color_border"     /></label><br />
				<label><span>에디터 배경 색    </span><input type="color" name="color_editor"     /></label><label><span>기본 글씨/커서 색 </span><input type="color" name="color_text"       /></label><br />
				<label><span>버튼 활성 색      </span><input type="color" name="color_hover"      /></label><label><span>화면 싱크 표시    </span><input type="color" name="color_syncBorder" /></label><br />
				<label><span>싱크 역전 표현    </span><input type="color" name="color_syncError"  /></label><label><span>싱크 중복 표현    </span><input type="color" name="color_syncEqual"  /></label><br />
			</div>
		</fieldset>
		<label id="areaNewFile">새 문서
		</label>
		<br />
		<label for="taViewerCss">미리보기</label> / <label>글씨 크기 <input type="number" name="viewer_size" style="width: 40px" /> (팟플레이어 기준)</label>
		<textarea id="taViewerCss" name="viewer_css" spellcheck="false" style="height: 300px;"></textarea>
	</form>
	
	<form id="player">
		<label>동영상 파일 확장자: <input type="text" name="player_exts" style="width: calc(100% - 140px);" /></label>
		<fieldset>
			<legend>플레이어: <select name="player_control_dll"></select></legend>
			<label>실행파일: <input type="text" name="player_control_what_path" style="width: calc(100% - 170px);" /></label><button id="btnPlayerPath" style="width: 100px;">찾아보기...</button><br />
			<label><input type="checkbox" name="player_control_what_withRun"  /> 프로그램 실행 시 플레이어 실행</label><br />
			<label><input type="checkbox" name="player_control_what_withExit" /> 프로그램 종료 시 플레이어 종료</label><br />
		</fieldset>
		<span>※ 다른 플레이어를 연동하고 싶으신 분은 "프로그램 폴더\bridge\readme.txt"를 참고하시기 바랍니다.</span>
	</form>

	<form id="menu">
		<ol id="menuList"></ol>
		<button type="button" class="add-menu">추가</button>
	</form>
</div>
<div id="applyArea">
	<button type="button" id="btnSubmit" accesskey="S">적용(<u>S</u>)</button>
	<button type="button" id="btnLoadDefault">기본값으로</button>
	<button type="button" id="btnLoadSetting">현재 설정으로</button>
</div>
</body>
</html>