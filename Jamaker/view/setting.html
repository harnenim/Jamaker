<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>설정</title>
<script src="lib/jquery-3.2.1.min.js"></script>
<script src="lib/popup.js"></script>
<script src="lib/History.js"></script>
<script src="lib/SubtitleObject.js"></script>
<script src="lib/SmiEditor.js"></script>
<link rel="stylesheet" type="text/css" href="lib/popup.css" />
<link rel="stylesheet" type="text/css" href="lib/SmiEditor.css" />
<script>
windowName = "setting";

let styleColorAppendPreset = "";
_setColor = setColor;
setColor = function(color) {
	_setColor(color);

	let preset = styleColorAppendPreset;
	for (let name in color) {
		preset = preset.replaceAll("["+name+"]", color[name]);
	}
	$("#styleColorAppend").html(preset);;
}

$(() => {
	const setting = JSON.parse(JSON.stringify(opener.setting));
	const oSmiEditor = opener.SmiEditor;
	
	styleColorAppendPreset = $("#styleColorAppend").html();
	setColor(setting.color);
	SmiEditor.scrollShow = setting.scrollShow;
	
	let lastFocus = null;
	
	// 전역에서 접근 가능해야 함
	window.show = function(index) {
		$("#settingNav > a.selected").removeClass("selected");
		$("#settingNav > a:eq(" + index + ")").addClass("selected");
		$("#settingArea > form.selected").removeClass("selected");
		opened = $("#settingArea > form:eq(" + index + ")").addClass("selected").attr("id");
		// 지역변수 setting도 건드려야 함
		opener.setting.show = setting.show = index;
		lastFocus = null;
	}
	$(document).on("focus", "input,textarea", function(e) {
		lastFocus = $(this);
		
	}).on("keydown", function(e) {
		if (e.ctrlKey) {
			switch (e.key) {
				case "Tab": {
					// Ctrl+Tab 탭 전환
					let index = setting.show;
					if (e.shiftKey) {
						index = (index + 7) % 8;
					} else {
						index = (index + 1) % 8;
					}
					show(index);
					break;
				}
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8": {
					// Ctrl + 숫자 탭 전환
					show(Number(e.key) - 1);
				}
			}
		}
	}).on("keyup", function(e) {
		if (e.altKey && e.key == "s") {
			// Alt+S 했을 땐 포커스 원위치
			lastFocus && lastFocus.focus();
		}
	});
	let opened = null;
	const submitFuncs = {};
	const refreshFuncs = {};
	let refreshTableCommand = () => {};
	
	const saved = {};
	function checkSaved(key, ok, no) {
		if (saved[key].status) {
			if (ok) ok();
			return;
		}
		confirm(saved[key].name + " 변경사항이 사라집니다.", ok, no);
	}
	function setSaved(key, status) {
		const item = saved[key];
		if (item) {
			item.status = status;
		}
	}
	function requestClose(keys) {
		if (!keys) {
			keys = [];
			for (let key in saved) {
				keys.push(key);
			}
		}
		if (keys.length) {
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				checkSaved(key, () => {
					requestClose(keys.slice(i + 1));
				});
				success = false;
				break;
			}
		} else {
			window.close();
		}
	}
	
	function refresh(form, setting) {
		form.find("input[type=text][name],input[type=number][name],input[type=color][name],input[type=range][name],textarea[name]").each((_, el) => {
			const input = $(el);
			let name = input.attr("name");
			if (name.indexOf("what") > 0) {
				name = name.replaceAll("what", setting.player.control.dll);
			}
			const value = eval("setting['" + name.replaceAll("_", "']['") + "']");
			if (typeof value == "number" || typeof value == "string") {
				input.val(value);
			} else if (value && value.join) {
				input.val(value.join("\n"));
			}
		});
		form.find("input[type=checkbox][name]").each((_, el) => {
			const input = $(el);
			let name = input.attr("name");
			if (name.indexOf("what")) {
				name = name.replaceAll("what", setting.player.control.dll);
			}
			input.prop("checked", eval("setting['" + name.replaceAll("_", "']['") + "']"));
		});
		form.find("select[name]").each((_, el) => {
			const select = $(el);
			const name = select.attr("name");
			const value = eval("setting." + name.replaceAll("_", "."));
			select.data({value: value});
		});
	}
	
	const fieldEditor = $("#fieldEditor");
	const fieldViewer = $("#fieldViewer");
	const fieldPlayer = $("#fieldPlayer");
	
	const tableCommand = $("#tableCommand");
	const inputCommandName = $("#inputCommandName");
	const inputCommandKey  = $("#inputCommandKey" );
	const inputCommandFunc = $("#inputCommandFunc");
	
	{	// 창
		(refreshFuncs["window"] = (setting) => {
			refresh($("#window"), setting);
			
			// 값에 맞춰 fieldset 이동
			const editor = [setting.window       , fieldEditor];
			const viewer = [setting.viewer.window, fieldViewer];
			const player = [setting.player.window, fieldPlayer];
			
			{
				const ecss = {};
				const vcss = {};
				const pcss = {};
				
				function setLeft(css, x) {
					css.left = x + 1;
				}
				function setRight(css, x) {
					css.width = (x - css.left - 2) + "%";
					css.left = css.left + "%";
				}
				function setTop(css, y) {
					css.top = y + 1;
				}
				function setBottom(css, y) {
					css.height = (y - css.top - 2) + "%";
					css.top = css.top + "%";
				}
				
				const targetXY = [
					[	[ editor[0].x, (x) => { setLeft(ecss, x); } ]
					,	[ editor[0].x + editor[0].width, (x) => { setRight(ecss, x); } ]
					,	[ viewer[0].x, (x) => { setLeft(vcss, x); } ]
					,	[ viewer[0].x + viewer[0].width, (x) => { setRight(vcss, x); } ]
					,	[ player[0].x, (x) => { setLeft(pcss, x); } ]
					,	[ player[0].x + player[0].width, (x) => { setRight(pcss, x); } ]
					]
				,	[	[ editor[0].y, (y) => { setTop(ecss, y); } ]
					,	[ editor[0].y + editor[0].height, (y) => { setBottom(ecss, y); } ]
					,	[ viewer[0].y, (y) => { setTop(vcss, y); } ]
					,	[ viewer[0].y + viewer[0].height, (y) => { setBottom(vcss, y); } ]
					,	[ player[0].y, (y) => { setTop(pcss, y); } ]
					,	[ player[0].y + player[0].height, (y) => { setBottom(pcss, y); } ]
					]
				];
				for (let xy = 0; xy < 2; xy++) {
					const targets = targetXY[xy];
					targets.sort((a, b) => { return a[0] - b[0]; });
					
					let last = [targets[0]];
					const ps = [last];
					for (let i = 1; i < targets.length; i++) {
						const curr = targets[i];
						if (curr[0] == last[0][0]) {
							last.push(curr);
						} else {
							last = [curr];
							ps.push(last);
						}
					}
					function getPos(i) {
						return 1 + ((98 / (ps.length - 1)) * i);
					}
					for (let i = 0; i < ps.length; i++) {
						const curr = ps[i];
						for (let j = 0; j < curr.length; j++) {
							curr[j][1](getPos(i));
						}
					}
				}
				fieldEditor.css(ecss);
				fieldViewer.css(vcss);
				fieldPlayer.css(pcss);
			}
			
			setSaved("window"
				,  (JSON.stringify(setting.window) == JSON.stringify(opener.setting.window))
				&& (JSON.stringify(setting.viewer.window) == JSON.stringify(opener.setting.viewer.window))
				&& (JSON.stringify(setting.player.window) == JSON.stringify(opener.setting.player.window))
			);
		})(setting);
		
		submitFuncs["window"] = () => {
			setting.window.x             = Number($("input[name=window_x]"            ).val());
			setting.window.y             = Number($("input[name=window_y]"            ).val());
			setting.window.width         = Number($("input[name=window_width]"        ).val());
			setting.window.height        = Number($("input[name=window_height]"       ).val());
			setting.viewer.window.x      = Number($("input[name=viewer_window_x]"     ).val());
			setting.viewer.window.y      = Number($("input[name=viewer_window_y]"     ).val());
			setting.viewer.window.width  = Number($("input[name=viewer_window_width]" ).val());
			setting.viewer.window.height = Number($("input[name=viewer_window_height]").val());
			setting.player.window.x      = Number($("input[name=player_window_x]"     ).val());
			setting.player.window.y      = Number($("input[name=player_window_y]"     ).val());
			setting.player.window.width  = Number($("input[name=player_window_width]" ).val());
			setting.player.window.height = Number($("input[name=player_window_height]").val());
			setting.player.window.use    = $("input[name=player_window_use]").prop("checked");
			setting.window.follow        = $("input[name=window_follow]").prop("checked");
			opener.setSetting(setting);
			opener.saveSetting();
			opener.moveWindowsToSetting();
			setTimeout(() => { // 딜레이 줘야 정상적으로 계산됨
				opener.refreshPaddingBottom();
			}, 10);
			refreshFuncs["window"](setting);
		};
		
		$("#btnGetWindows").on("click", function() {
			opener.binder.getWindows(JSON.stringify(["editor", "viewer", "player"]));
		});
		// C#에서 Script("afterGetWindow", object[] { "editor", x, y, w, h });
		opener.afterGetWindow = (id, x, y, w, h) => {
			const name = (id == "editor")
			           ? "window"
			           : (id + "_window");
			$("input[name=" + name + "_x]"     ).val(x);
			$("input[name=" + name + "_y]"     ).val(y);
			$("input[name=" + name + "_width]" ).val(w);
			$("input[name=" + name + "_height]").val(h);
		};
	}
	
	{	// 싱크
		(refreshFuncs["sync"] = (setting) => {
			refresh($("#sync"), setting);
			setSaved("sync", (JSON.stringify(setting.sync) == JSON.stringify(opener.setting.sync)));
		})(setting);
		
		submitFuncs["sync"] = () => {
			const preset = $("input[name=sync_preset]").val();
			
			// TODO: 프리셋 양식 오류 검증 필요?
			//       차라리 설정을 없앨까?
			// <Sync Start={sync}><P Class={lang}{type}>
			
			setting.sync.insert   = Number($("input[name=sync_insert]").val());
			setting.sync.update   = Number($("input[name=sync_update]").val());
			setting.sync.weight   = Number($("input[name=sync_weight]").val());
			setting.sync.unit     = Number($("input[name=sync_unit]"  ).val());
			setting.sync.move     = Number($("input[name=sync_move]"  ).val());
			setting.sync.lang     = $("input[name=sync_lang]"  ).val();
			setting.sync.preset   = preset;
			setting.sync.frame    = $("input[name=sync_frame]" ).prop("checked");
			setting.sync.kframe   = $("input[name=sync_kframe]").prop("checked");
			setting.sync.kLimit   = Number($("input[name=sync_kLimit]").val());
			setting.sync.holds    = $("input[name=sync_holds]").prop("checked");
			setting.sync.width    = Number($("input[name=sync_width]" ).val());
			setting.sync.height   = Number($("input[name=sync_height]").val());
			setting.sync.uiWidth  = Number($("input[name=sync_uiWidth]" ).val());
			setting.sync.uiHeight = Number($("input[name=sync_uiHeight]").val());
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 단축키
		saved.cmd = { status: true, name: "단축키 설정" };
		
		refreshFuncs["cmd"] = (setting) => {
			if (setting == opener.setting) {
				checkSaved("cmd", () => {
					setSaved("cmd", true);
					inputCommandName.val("");
					inputCommandKey .val("");
					inputCommandFunc.val("");
				});
				
			} else {
				confirm("현재 값은 복원할 수 없습니다.", () => {
					opener.setting.command = opener.deepCopyObj(setting.command);
					setSaved("cmd", true);
					inputCommandName.val("");
					inputCommandKey .val("");
					inputCommandFunc.val("");
					refreshTableCommand();
					opener.setSetting(opener.setting);
					opener.saveSetting();
				});
			}
		};
		
		const tbody = tableCommand.find("tbody");
		const withs = ["withCtrls", "withAlts", "withCtrlAlts", "withCtrlShifts"];
		const keys = "pqrstuvwxyz{ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=";
		const keyNames = ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12"].concat("ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=".split(""));
		(refreshTableCommand = () => {
			tbody.empty();
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				const keyName = (i < 12)
				              ? ("F" + (i + 1))
				              : key;
				const th = $("<th>").text(keyName);
				if (i < 12) {
					let func = setting.command.fn[key];
					if (!func || !func.trim()) {
						func = "";
						th.addClass("not-used");
					} else {
						let label = func.trim();
						if (label.substring(0, 2) == "/*") {
							label = label.substring(2).split("*/")[0].trim();
						}
						th.addClass("used").attr({ title: label });
					}
					th.data({
							"name": "setting.command.fn['" + key + "']"
						,	"key" : key
						,	"func": func
					});
				}
				const tr = $("<tr>").addClass("key-" + (keyName=='`' ? 'ㄹ' : (keyName=='=' ? '＝' : keyName))).append(th);
				for (let j = 0; j < withs.length; j++) {
					const w = withs[j];
					const td = $("<td>");
					if (oSmiEditor[w].reserved.indexOf(key) >= 0) {
						let func = oSmiEditor[w][key];
						let label = func;
						if (label) {
							let type = typeof label;
							if (type == "string") {
								label = label.trim();
								if (label.substring(0, 2) == "/*") {
									label = label.substring(2).split("*/")[0].trim();
								}
							} else if (type == "function") {
								label = label.name;
							}
						} else {
							label = "시스템 단축키";
						}
						label = "예약: " + label;
						td.addClass("fixed").text(label);
					} else {
						let func = setting.command[w][key];
						if (!func || !func.trim()) {
							func = "";
						} else {
							let label = func.trim();
							if (label.substring(0, 2) == "/*") {
								label = label.substring(2).split("*/")[0].trim();
							}
							td.addClass("used").text(label);
						}
						td.data({
								"name": "setting.command." + w + "['" + key + "']"
							,	"with": j
							,	"key" : key
							,	"func": func
						});
					}
					tr.append(td);
				}
				tbody.append(tr);
			}
		})();
		
		// TODO: 이쪽은 함부로 keyCode 걷어내기 힘듦...
		tableCommand.on("click", "th.used, th.not-used, td:not(.fixed)", function() {
			const data = $(this).data();
			const keyCode = data.key.charCodeAt();
			let keyName = (111 < keyCode && keyCode < 192) 
			            ? ("F" + (keyCode - 111))
			            : data.key;
			switch (data.with) {
				case 0: {
					keyName = "Ctrl + " + keyName;
					break;
				}
				case 1: {
					keyName = "Alt + " + keyName;
					break;
				}
				case 2: {
					keyName = "Ctrl + Alt + " + keyName;
					break;
				}
				case 3: {
					keyName = "Ctrl + Shift + " + keyName;
					break;
				}
			}
			
			if (inputCommandKey.val() == keyName) {
				// 현재 작업 중인 것
				return;
			}
			checkSaved("cmd", () => {
				setSaved("cmd", true);
				inputCommandName.val(data.name);
				inputCommandKey .val(keyName);
				inputCommandFunc.val(data.func);
			});
		});
		
		inputCommandKey.on("keydown", function(e) {
			e.preventDefault();
			e.stopPropagation();
			
			let name = "";
			let key = String.fromCharCode(e.keyCode);
			let func = "";
			switch (e.keyCode) {
				case 192: key = '`'; break;
				case 189: key = '-'; break;
				case 187: key = '='; break;
			}
			
			if (keys.indexOf(key) >= 0) {
				let keyName = (111 < e.keyCode && e.keyCode < 124)
				            ? ("F" + (e.keyCode - 111))
				            : key;
				const keyIndex = keyNames.indexOf(keyName);
				const selector = "tr.key-" + (keyName=='`' ? 'ㄹ' : (keyName=='=' ? '＝' : keyName));
				
				let w = null;
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							if (oSmiEditor.withCtrlShifts.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + Shift + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(3)").data("func");
								name = "setting.command.withCtrlShifts[\"" + key + "\"]";
								keyName = "Ctrl + Shift + " + keyName;
							}
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							if (oSmiEditor.withCtrlAlts.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + Alt + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(2)").data("func");
								name = "setting.command.withCtrlAlts[\"" + key + "\"]";
								keyName = "Ctrl + Alt + " + keyName;
							}
						} else {
							if (oSmiEditor.withCtrls.reserved.indexOf(key) >= 0) {
								keyName = "Ctrl + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(0)").data("func");
								name = "setting.command.withCtrls[\"" + key + "\"]";
								keyName = "Ctrl + " + keyName;
							}
						}
					} else {
						if (e.altKey) {
							if (oSmiEditor.withAlts.reserved.indexOf(key) >= 0) {
								keyName = "Alt + 예약키";
							} else {
								func = tableCommand.find(selector + " > td:eq(1)").data("func");
								name = "setting.command.withAlts[\"" + key + "\"]";
								keyName = "Alt + " + keyName;
							}
						} else {
							func = tableCommand.find(selector + " > th:eq(0)").data("func");
							name = "setting.fn[\"" + key + "\"]";
						}
					}
				}
				
				if (inputCommandKey.val() == keyName) {
					// 현재 작업 중인 것
					return;
				}
				$("#areaTableCommand").scrollTop(keyIndex * 20);
				checkSaved("cmd", () => {
					inputCommandName.val(name);
					inputCommandKey .val(keyName);
					inputCommandFunc.val(func);
				});
				
			} else {
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							key = "Ctrl + Shift + ";
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							key = "Ctrl + Alt + ";
						} else {
							key = "Ctrl + ";
						}
					} else {
						if (e.altKey) {
							key = "Alt + ";
						} else {
							
						}
					}
				}
			}
		});
		
		inputCommandFunc.bind("input propertychange", function() {
			if (inputCommandKey.val().length > 1) { // 한 글자인 경우 단축키 조합 아님
				setSaved("cmd", false);
			} else {
				// 입력 차단
				inputCommandFunc.val("");
			}
		});
		
		$("#areaFunctions").on("click", "li", function() {
			const func = inputCommandFunc.val();
			inputCommandFunc.val((func ? func + "\n" : "") + $(this).data("input"));
			if (inputCommandName.val()) {
				setSaved("cmd", false);
			}
		});
		
		submitFuncs["cmd"] = () => {
			const name = inputCommandName.val();
			if (name) {
				let func = inputCommandFunc.val();
				if (func.trim().length == 0) {
					func = " ";
				}
				eval(name + " = func;");
				setSaved("cmd", true);
				refreshTableCommand();
				opener.setSetting(setting);
				opener.saveSetting();
			}
		};
	}
	
	{	// 자동완성
		(refreshFuncs["ac"] = (setting) => {
			refresh($("#ac"), setting);
			setSaved("ac", (JSON.stringify(setting.autoComplete) == JSON.stringify(opener.setting.autoComplete)));
		})(setting);
		
		submitFuncs["ac"] = () => {
			$("#ac").find("textarea").each((_, el) => {
				const textarea = $(el);
				const name = "setting['" + textarea.attr("name").replaceAll("_", "']['") + "']";
				let value = textarea.val();
				if (value) {
					value = value.split("\n");
				} else {
					value = [];
				}
				eval(name + " = value");
			});
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 자동치환
		saved.replace = { status: true, name: "자동치환 설정" };
		
		const replaceList = $("#replaceList");
		
		function appendReplace(item) {
			if (!item) {
				item = { from: "", to: "", use: true };
			}
			replaceList.append(
				$("<li>")
					.append($("<input type='text' name='from'>").val(item.from))
					.append("→")
					.append($("<input type='text' name='to'>"  ).val(item.to))
					.append($("<input type='checkbox' name='use'>").prop("checked", item.use))
					.append($("<button type='button' class='prev'>").text("∧"))
					.append($("<button type='button' class='next'>").text("∨"))
					.append($("<button type='button' class='remove'>").text("✕"))
			);
		}
		(refreshFuncs["replace"] = (setting) => {
			refresh($("#replace"), setting);
			replaceList.empty();
			for (let i = 0; i < setting.replace.length; i++) {
				appendReplace(setting.replace[i]);
			}
			setSaved("replace"
				,  (setting.saveWithNormalize == opener.setting.saveWithNormalize)
				&& (JSON.stringify(setting.command) == JSON.stringify(opener.setting.command))
			);
		})(setting);
		
		$("#replace > .add-replace").on("click", function() {
			appendReplace();
			setSaved("replace", false);
		});
		
		replaceList.on("click", "li > button.prev", function() {
			const li = $(this).parent();
			const prev = li.prev();
			if (prev.length) {
				prev.before(li);
				setSaved("replace", false);
			}
		});
		replaceList.on("click", "li > button.next", function() {
			const li = $(this).parent();
			const next = li.next();
			if (next.length) {
				next.after(li);
				setSaved("replace", false);
			}
		});
		replaceList.on("click", "li > button.remove", function() {
			const li = $(this).parent();
			confirm("삭제하시겠습니까?", function() {
				li.remove();
				setSaved("replace", false);
			});
		});
		
		submitFuncs["replace"] = () => {
			const replaces = [];
			
			replaceList.find("li").each((_, el) => {
				const li = $(el);
				const item = {
						from: li.find("input[name=from]").val()
					,	to  : li.find("input[name=to]").val()
					,	use : li.find("input[name=use]").prop("checked")
				};
				if (item.from && item.to) {
					replaces.push(item);
				}
			});
			
			setting.saveWithNormalize = $("input[name=saveWithNormalize]").prop("checked");
			setting.replace = replaces;
			setSaved("replace", true);
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 스타일
		saved.style = { status: true, name: "스타일 설정" };
		
		const presetUl = $("#style_color_preset ul");
		presetUl.on("click", "li span", function() {
			const color = setting.colorPreset[$(this).parent().data("key")];
			for (let name in color) {
				$("input[name=color_" + name + "]").val(color[name]);
			}
		}).on("click", "li button", function() {
			const key = $(this).parent().data("key");
			confirm("삭제하시겠습니까?", () => {
				delete(setting.colorPreset[key]);
				refreshPreset(setting);
			});
		});
		$("#btnAddPreset").on("click", () => {
			const name = prompt("프리셋 이름을 입력하세요.");
			if (!name) {
				alert("이름이 입력되지 않았습니다.");
			}
			const color = {};
			color.background = $("input[name=color_background]").val();
			color.selector   = $("input[name=color_selector]"  ).val();
			color.border     = $("input[name=color_border]"    ).val();
			color.tab        = $("input[name=color_tab]"       ).val();
			color.tabBorder  = $("input[name=color_tabBorder]" ).val();
			color.editor     = $("input[name=color_editor]"    ).val();
			color.text       = $("input[name=color_text]"      ).val();
			color.hover      = $("input[name=color_hover]"     ).val();
			color.notSaved   = $("input[name=color_notSaved]"  ).val();
			color.syncBorder = $("input[name=color_syncBorder]").val();
			color.syncError  = $("input[name=color_syncError]" ).val();
			color.syncEqual  = $("input[name=color_syncEqual]" ).val();
			setting.colorPreset[name] = color;
			refreshPreset(setting);
		});
		function refreshPreset(setting) {
			presetUl.empty();
			for (let key in setting.colorPreset) {
				const li = $("<li>").data({ key: key });
				li.append($("<span>").text(key)).append($("<button>").attr({ type: "button" }).text("×"));
				presetUl.append(li);
			}
		}
		
		function refreshHighlight() {
			SmiEditor.setHighlight({
					parser: $("select[name=highlight_parser]").val()
				,	style : $("select[name=highlight_style]").val()
				,	enter : $("input[name=highlight_enter]").prop("checked")
				,	color : $("input[name=highlight_color]").prop("checked")
				,	sync  : Number($("input[name=highlight_sync]").val())
			}, [editorNewFile]);
		}
		const editorNewFile = new SmiEditor();
		const labelNewFile = $("#areaNewFile").append(editorNewFile.area.height(400));
		{	// textarea resize
			let resizeNewFile = false;
			editorNewFile.input.attr({ name: "newFile" }).height(398).on("mousedown", function() {
				resizeNewFile = true;
			});
			$(document).on("mousemove", function() {
				if (!resizeNewFile) return;
				editorNewFile.area.height(editorNewFile.input.outerHeight() + 2);
			}).on("mouseup", function() {
				resizeNewFile = false;
			});
		}
		
		$("input[name=defStyle_OutlineColour], input[name=defStyle_BackColour]").each(function() {
			const $input = $(this);
			$input.next().val($input.val().toUpperCase());
		}).on("input propertychange", function () {
			const $input = $(this);
			$input.next().val($input.val().toUpperCase());
		});
		$("input.color").on("input propertychange", function () {
			const $input = $(this);
			const color = $input.val();
			if (color.startsWith("#") && color.length == 7) {
				if (isFinite("0x" + color.substring(1))) {
					$input = $input.prev().val(color);
				} else {
					return;
				}
			} else {
				return;
			}
		});
		
		(refreshFuncs["style"] = (setting) => {
			refresh($("#style"), setting);
			refreshPreset(setting);
			setSaved("style"
				,  (setting.useTab == opener.setting.useTab)
				&& (setting.viewer.useAlign == opener.setting.viewer.useAlign)
				&& (JSON.stringify(setting.highlight  ) == JSON.stringify(opener.setting.highlight  ))
				&& (JSON.stringify(setting.color      ) == JSON.stringify(opener.setting.color      ))
				&& (JSON.stringify(setting.colorPreset) == JSON.stringify(opener.setting.colorPreset))
				&& (JSON.stringify(setting.newFile    ) == JSON.stringify(opener.setting.newFile    ))
				&& (JSON.stringify(setting.viewer.css ) == JSON.stringify(opener.setting.viewer.css ))
			);
			editorNewFile.render();
			refreshHighlight();
		})(setting);
		
		let selectParser = $("select[name=highlight_parser]");
		let selectStyle  = $("select[name=highlight_style]" );
		let selectSize   = $("select[name=size]");
		if (opener.highlights) {
			for (let i = 0; i < opener.highlights.length; i++) {
				const item = opener.highlights[i].trim();
				if (item.length) {
					const split = item.split(":");
					const value = split[0].trim();
					let name = (split.length > 1) ? split[1].trim() : value;
					if (name.indexOf("?")) name = name.split("?")[0];
					selectStyle.append($("<option>").val(value).text(name));
				}
			}
			selectParser.find("option[value='" + setting.highlight.parser + "']").prop("selected", true);
			selectStyle .find("option[value='" + setting.highlight.style  + "']").prop("selected", true);
		}
		$([	"select[name=highlight_parser]"
		,	"select[name=highlight_style]"
		,	"input[name=highlight_enter]"
		,	"input[name=highlight_color]"].join(",")).on("change", function() {
			refreshHighlight();
		});
		selectParser.on("change", function() {
			if (selectParser.val()) {
				$("#style_highlight_setting").removeClass("disabled").find("input, select[name=highlight_style]").attr({ disabled: false });
			} else {
				$("#style_highlight_setting").addClass   ("disabled").find("input, select[name=highlight_style]").attr({ disabled: true  });
			}
		}).change();
		
		selectSize.find("option[value='" + selectSize.data("value") + "']").prop("selected", true);
		
		$("#style").on("input propertychange", function() {
			setSaved("style", false);
		});
		
		submitFuncs["style"] = () => {
			setting.size             = $("select[name=size]").val();
			setting.useTab           = $("input[name=useTab]").prop("checked");
			
			setting.highlight.parser = $("select[name=highlight_parser]").val();
			setting.highlight.style  = $("select[name=highlight_style]").val();
			setting.highlight.enter  = $("input[name=highlight_enter]").prop("checked");
			setting.highlight.color  = $("input[name=highlight_color]").prop("checked");
			setting.highlight.sync   = Number($("input[name=highlight_sync]").val());
			
			setting.scrollMargin     = Number($("input[name=scrollMargin]").val());
			setting.scrollShow       = Number($("input[name=scrollShow]").val());
			
			setting.viewer.useAlign  = $("input[name=viewer_useAlign]").prop("checked");
//			setting.viewer.size      = $("input[name=viewer_size]").val();
			setting.viewer.css       = $("textarea[name=viewer_css]").val();
			
			setting.newFile          = $("textarea[name=newFile]"   ).val();
			
			setting.color.background = $("input[name=color_background]").val();
			setting.color.selector   = $("input[name=color_selector]"  ).val();
			setting.color.border     = $("input[name=color_border]"    ).val();
			setting.color.tab        = $("input[name=color_tab]"       ).val();
			setting.color.tabBorder  = $("input[name=color_tabBorder]" ).val();
			setting.color.editor     = $("input[name=color_editor]"    ).val();
			setting.color.text       = $("input[name=color_text]"      ).val();
			setting.color.hover      = $("input[name=color_hover]"     ).val();
			setting.color.notSaved   = $("input[name=color_notSaved]"  ).val();
			setting.color.syncBorder = $("input[name=color_syncBorder]").val();
			setting.color.syncError  = $("input[name=color_syncError]" ).val();
			setting.color.syncEqual  = $("input[name=color_syncEqual]" ).val();
			
			const defaultHolds = [];
			{
				for (let t = 0; t < opener.tabs.length; t++) {
					const tab = opener.tabs[t];
					for (let h = 0; h < tab.holds.length; h++) {
						const hold = tab.holds[h];
						if (!hold.style) {
							// 기본 스타일이면 적용
							defaultHolds.push(hold);
						} else {
							if (opener.SmiFile.toSaveStyle(hold.style, setting.defStyle) == "") {
								// 기본 스타일이면 적용
								defaultHolds.push(hold);
							}
						}
					}
				}
			}
			setting.defStyle.Fontname        = $("input[name=defStyle_Fontname]"     ).val();
			setting.defStyle.Fontsize = Number($("input[name=defStyle_Fontsize]"     ).val());
			setting.defStyle.Bold            = $("input[name=defStyle_Bold]"         ).prop("checked");
			setting.defStyle.OutlineColour   = $("input[name=defStyle_OutlineColour]").val();
			setting.defStyle.Outline  = Number($("input[name=defStyle_Outline]"      ).val());
			setting.defStyle.BackColour      = $("input[name=defStyle_BackColour]"   ).val();
			setting.defStyle.Shadow   = Number($("input[name=defStyle_Shadow]"       ).val());
			setting.defStyle.MarginL = setting.defStyle.MarginR = Number($("input[name=defStyle_MarginL]").val());
			setting.defStyle.MarginV  = Number($("input[name=defStyle_MarginV]"      ).val());
			if (!setting.defStyle.Fontname) {
				$("input[name=defStyle_Fontname]").val(setting.defStyle.Fontname = "맑은 고딕");
			}
			setting.viewer.size = setting.defStyle.Fontsize / 80 * 18;
			
			refreshHighlight();
			setSaved("style", true);
			opener.setSetting(setting);
			opener.saveSetting();
			setColor(setting.color);
			SmiEditor.scrollShow = setting.scrollShow;
			
			for (let i = 0; i < defaultHolds.length; i++) {
				defaultHolds[i].setStyle(JSON.parse(JSON.stringify(setting.defStyle)));
			}
		};
	}
	
	{	// 플레이어
		(refreshFuncs["player"] = (setting) => {
			refresh($("#player"), setting);
			setSaved("player"
				,  (setting.exts == opener.setting.exts)
				&& (JSON.stringify(setting.player.control) == JSON.stringify(opener.setting.player.control))
			);
		})(setting);
		
		const select = $("select[name=player_control_dll]");
		if (opener.playerDlls) {
			for (let i = 0; i < opener.playerDlls.length; i++) {
				const dll = opener.playerDlls[i].split(":");
				select.append($("<option>").val(dll[0].trim()).text(dll[1].trim()));
			}
			select.find("option[value='" + select.data("value") + "']").prop("selected", true);
		}
		select.on("change", function() {
			const dll = select.val();
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = {
						path: ""
					,	withRun: true
					,	withExit: true
				};
			}
			$("input[name=player_control_what_path]"    ).val(dllSetting.path);
			$("input[name=player_control_what_withRun]" ).prop("checked", dllSetting.withRun);
			$("input[name=player_control_what_withExit]").prop("checked", dllSetting.withExit);
		});
		
		$("#btnPlayerPath").on("click", function() {
			opener.binder.selectPlayerPath();
		});
		opener.afterSelectPlayerPath = (path) => {
			$("input[name=player_control_what_path]").val(path);
		};
		
		submitFuncs["player"] = () => {
			setting.player.exts = $("input[name=player_exts]").val();
			const dll = setting.player.control.dll = select.val();
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = setting.player.control[dll] = {};
			}
			dllSetting.path     = $("input[name=player_control_what_path]"    ).val();
			dllSetting.auto     = $("input[name=player_control_what_auto]"    ).prop("checked");
			dllSetting.withRun  = $("input[name=player_control_what_withRun]" ).prop("checked");
			dllSetting.withExit = $("input[name=player_control_what_withExit]").prop("checked");
			opener.setSetting(setting);
			opener.saveSetting();
			opener.binder.setVideoExts(setting.player.exts);
		};
	}
	
	{	// 메뉴
		saved.menu = { status: true, name: "메뉴 설정" };
		
		const menuList = $("#menuList");
		
		function appendMenu(menus) {
			if (!menus) menus = [""];
			
			const fieldset = $("<fieldset>");
			const legend = $("<legend>")
				.append($("<input type='text'>").val(menus[0]))
				.append($("<button type='button' class='prev'>").text("∧"))
				.append($("<button type='button' class='next'>").text("∨"))
				.append($("<button type='button' class='remove'>").text("✕"));
			fieldset.append(legend);
			
			const ol = $("<ol>");
			fieldset.append(ol);
			
			for (let j = 1; j < menus.length; j++) {
				const menu = menus[j].split("|");
				const name = menu[0];
				const func = menu.slice(1).join("|");
				appendSubMenu(ol, name, func);
			}
			
			fieldset.append($("<button type='button' class='add-menu'>").text("추가"));
			
			const li = $("<li>").append(fieldset);
			menuList.append(li);
			return li;
		}
		function appendSubMenu(ol, name, func) {
			if (!ol) return;
			if (!name) name = "";
			if (!func) func = "";
			const li = $("<li>")
					.append($("<input type='text' placeholder='이름을 비우면 구분선이 됩니다.'>").val(name))
					.append($("<button type='button' class='prev'>").text("∧"))
					.append($("<button type='button' class='next'>").text("∨"))
					.append($("<input type='text' class='menu-func'>").val(func))
					.append($("<button type='button' class='remove'>").text("✕"));
			ol.append(li);
			return li;
		}
		(refreshFuncs["menu"] = (setting) => {
			menuList.empty();
			for (let i = 0; i < setting.menu.length; i++) {
				appendMenu(setting.menu[i]);
			}
			setSaved("menu", (JSON.stringify(setting.menu) == JSON.stringify(opener.setting.menu)));
		})(setting);
		
		$("#menu > .add-menu").on("click", function() {
			appendMenu().find("input:eq(0)").focus();
			setSaved("menu", false);
		});
		
		menuList.on("click", ".add-menu", function() {
			appendSubMenu($(this).parent().find("ol")).find("input:eq(0)").focus();
			setSaved("menu", false);
		});
		
		menuList.on("click", "legend > button.prev", function() {
			const btn = $(this);
			const menu = btn.parents("li");
			const prev = menu.prev();
			if (prev.length) {
				prev.before(menu);
				setSaved("menu", false);
				btn.focus();
			}
		});
		menuList.on("click", "legend > button.next", function() {
			const btn = $(this);
			const menu = btn.parents("li");
			const next = menu.next();
			if (next.length) {
				next.after(menu);
				setSaved("menu", false);
				btn.focus();
			}
		});
		menuList.on("click", "legend > button.remove", function() {
			const menu = $(this).parents("li");
			confirm("삭제하시겠습니까?", () => {
				menu.remove();
				setSaved("menu", false);
			});
		});
		
		menuList.on("click", "ol > li > button.prev", function() {
			const btn = $(this);
			const subMenu = btn.parent();
			const prev = subMenu.prev();
			if (prev.length) {
				prev.before(subMenu);
				setSaved("menu", false);
				btn.focus();
			}
		});
		menuList.on("click", "ol > li > button.next", function() {
			const btn = $(this);
			const subMenu = btn.parent();
			const next = subMenu.next();
			if (next.length) {
				next.after(subMenu);
				setSaved("menu", false);
				btn.focus();
			}
		});
		menuList.on("click", "ol > li > button.remove", function() {
			const subMenu = $(this).parent();
			confirm("삭제하시겠습니까?", () => {
				subMenu.remove();
				setSaved("menu", false);
			});
		});
		
		submitFuncs["menu"] = () => {
			const menus = [];
			
			menuList.find("fieldset").each((_, el) => {
				const fieldset = $(el);
				const menu = [fieldset.find("legend > input").val()];
				
				fieldset.find("li").each((_, el) => {
					const inputs = $(el).find("input");
					menu.push(inputs[0].value + "|" + inputs[1].value);
				});
				menus.push(menu);
			});
			
			setting.menu = menus;
			setSaved("menu", true);
			opener.setSetting(setting);
			opener.saveSetting();
			
			// Alt 단축키 바뀌었을 수 있으므로 단축키 설정 새로고침
			refreshTableCommand();
		};
	}
	
	$("#btnLoadSetting").on("click", function() {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(setting);
		}
	});
	
	$("#btnLoadDefault").on("click", function() {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(opener.DEFAULT_SETTING);
		}
	});
	
	$("#btnSubmit").on("click", function() {
		const submitFunc = submitFuncs[opened];
		if (submitFunc) submitFunc();
	});
	
	$("form").each((_, el) => {
		const form = $(el);
		form.attr({ novalidate: true });
		form.on("submit", function(e) {
			e.preventDefault();
			submitFuncs[form.attr("id")]();
		});
		form.append($("<button type='submit'>").hide());
	});
	
	show(opener.setting.show ? opener.setting.show : 0);
});
</script>
<style>
* {
	font-size: 14px;
}
textarea {
	width: 100%;
	height: 100px;
	font-family: '돋움체'; /* 여기선 고정폭 문자 써야 할 듯 */
	resize: vertical;
}

input[type=number] { width: 50px; }

fieldset {
	padding: 8px;
	margin: 8px 0;
}

fieldset li { margin-bottom: 2px; }

/* 기본 틀 */
#settingNav {
	position: fixed;
	top: 0;
	left: 8px;
	right: 8px;
	height: 40px;
	padding-top: 8px;
	border-bottom: 1px solid #888;
}
#settingArea {
	position: fixed;
	top: 40px;
	left: 8px;
	right: 8px;
	bottom: 48px;
	overflow-y: scroll;
	border: 1px solid #888;
	border-top: 0;
	padding: 8px;
}
#applyArea {
	position: fixed;
	left: 0;
	right: 0;
	bottom: 0;
	height: 48px;
}
#btnLoadSetting,
#btnLoadDefault,
#btnSubmit {
	float: right;
	margin: 8px 8px 8px 0;
	min-width: 100px;
	padding: 4px;
	line-height: 22px;
	font-size: 16px;
}

/* 탭 UI */
#settingNav > a {
	display: block;
	float: left;
	margin: 0 -1px -1px 0;
	border: 1px solid #888;
	border-radius: 6px 6px 0 0;
	font-size: 16px;
	text-decoration: none;
	height: 32px;
	line-height: 32px;
	padding: 0 8px;
}
#settingArea > form {
	display: none;
}
#settingArea > form.selected {
	display: block;
}

/* 창 */
#btnGetWindows {
	padding: 4px;
}
#fieldWindow {
	width: 100%;
	height: calc(100% - 50px);
	position: relative;
}
#fieldWindow > fieldset {
	position: absolute;
}
#fieldWindow > fieldset:hover {
	z-index: 9999;
}
#fieldWindow > fieldset span {
	display: inline-block;
	width: 16px;
	text-align: center;
}

/* 단축키 */
#areaTableCommand {
	height: 210px;
	overflow-y: scroll;
	border-bottom: 1px solid #aaa;
	margin-bottom: 4px;
}
#tableCommand {
	width: 100%;
}
#tableCommand tr {
	height: 20px;
}
#tableCommand th.used,
#tableCommand th.not-used {
	cursor: pointer;
}
#tableCommand td {
	height: 20px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	cursor: pointer;
}
#tableCommand td.fixed {
	cursor: default;
}
#areaFunctions li {
	margin: 8px 0;
	border: 1px solid #ddd;
	border-radius: 8px;
	padding: 4px;
	cursor: pointer;
}
#areaFunctions h4 {
	margin-bottom: 4px;
}

/* 자동치환, 메뉴 */
#replaceList { margin: 8px 0 2px; }
#replaceList input[type=text] { width: calc(50% - 40px); }
#replaceList input[type=checkbox] { width: 17px; }
#replace > button.add-replace { width: 100%; margin-top: 8px; }

#replaceList button,
#menu button { width: 16px; }
#menu input,
#menu button.add-menu { width: 200px; }
#menu input.menu-func { width: calc(100% - 250px); margin-left: 2px; }
#menu > button.add-menu { width: 216px; margin-top: 8px; }

#replaceList button,
fieldset legend button,
fieldset ol button,
#btnPlayerPath { border-left-width: 0; }
#replace input + button { border-left-width: 1px; }

/* 스타일 */
#style_highlight_setting > div {
	float: left;
	margin-right: 4px;
}
#style_highlight_setting:after {
	display: block;
	content: ""; 
	clear: both;
	margin-bottom: 8px;
}
#style_highlight_setting label {
	margin-right: 8px;
}
#style_highlight_setting.disabled label > span {
	opacity: 0.5;
}
#style_highlight_setting select[name=highlight_parser],
#style_highlight_setting input[name=highlight_sync] {
	width: 101px;
}
#style_color_preset {
	float: left;
	width: 200px;
	height: 146px;
}
#style_color_preset ul {
	overflow-y: scroll;
	height: calc(100% - 18px);
}
#style_color_preset li {
	border: 1px solid #888;
	cursor: pointer;
	width: 100%;
	height: 20px;
	line-height: 20px;
}
#style_color_preset li:hover {
	background: #fff;
}
#style_color_preset li span {
	display: block;
	width: calc(100% - 16px);
	height: 18px;
	float: left;
	white-space: nowrap;
	overflow: hidden;
}
#style_color_preset li button {
	display: block;
	width: 16px;
	height: 18px;
	float: right;
	border-width: 0 0 0 1px;
}
#btnAddPreset {
	width: 100%;
}
#style_color_setting {
	float: left;
}
#style_color_setting label {
	display: inline-block;
	margin-left: 10px;
}
#style_color_setting span {
	display: inline-block;
	width: 140px;
}
#style_color:after {
	display: block;
	content: "";
	clear: both;
}
/* 새 문서 에디터 */
#areaNewFile .hold > .col-sync {
	display: none;
}
#areaNewFile .hold > .input {
	left: 0;
	height: 100%;
}
#areaNewFile .highlight-textarea {
	border: 1px solid #888;
}
#areaNewFile .highlight-textarea > textarea {
	resize: vertical;
}
/* ASS 기본 스타일 */
#style_ass span {
	display: inline-block;
	width: 70px;
}
#style_ass input[type=text],
#style_ass input[type=number],
#style_ass input[type=color] {
    height: 22px;
}
#style_ass input[type=text].color {
    width: 60px;
}

body.classic-scrollbar ::-webkit-scrollbar,
body.classic-scrollbar ::-webkit-scrollbar-button { width: calc(20px * 0.8 + 1px); height: calc(20px * 0.8 + 1px); }
body.classic-scrollbar ::-webkit-scrollbar-button:end { background-position-y: calc(20px * 0.8 + 1px); }
body.classic-scrollbar ::-webkit-scrollbar-button:horizontal { background-position-x: calc(20px * 0.8 + 1px); }
body:not(.classic-scrollbar) ::-webkit-scrollbar-thumb { border-radius: calc(20px * 0.5); border: calc(20px * 0.2) solid transparent; }

.input ::-webkit-scrollbar-thumb:hover { background-color: #aaaaaa; }
.input .scrolling::-webkit-scrollbar-thumb { background-color: #c1c1c1; }
.input .scrolling::-webkit-scrollbar-corner { background: #dddddd; }

</style>
<style id="styleColor"></style>
<style id="styleColorAppend">
body {
	background: [selector];
}
#settingArea fieldset {
	border-color: [tabBorder];
}

#settingArea,
#applyArea button {
	background: [background];
	color: [text];
}
#settingNav > a {
	background: [tab];
	color: [text];
}
#settingNav > a.selected {
	background: [background];
	border-bottom-color: [background];
}
#settingNav > a:hover {
	background: [background];
}

#fieldWindow > fieldset:hover {
	background: [hover]88;
}
#tableCommand {
	color: #000;
}
#tableCommand th {
	background: #e1e1e1;
}
#tableCommand th.not-used {
	background: #fff;
}
#tableCommand th.not-used:hover,
#tableCommand td:hover {
	background: #ff8;
}
#tableCommand td.fixed {
	background: #f88;
}
#tableCommand th.used,
#tableCommand td.used {
	background: #8ff;
}
#tableCommand th.used:hover,
#tableCommand td.used:hover {
	background: #cfc;
}
#areaFunctions li {
	border-color: [tab];
}
#areaFunctions li:hover {
	/*
	background: #ffd;
	*/
	background: [hover];
}

#style_color_preset li {
	border-color: [tabBorder];
}
#style_color_preset li:hover {
	background: [hover];
}
#areaNewFile .highlight-textarea {
	border-color: [tabBorder];
}
</style>
</head>
<body>

<nav id="settingNav">
	<a href="javascript:show(0)">창 배치</a>
	<a href="javascript:show(1)">싱크</a>
	<a href="javascript:show(2)">단축키</a>
	<a href="javascript:show(3)">자동완성</a>
	<a href="javascript:show(4)">자동치환</a>
	<a href="javascript:show(5)">스타일</a>
	<a href="javascript:show(6)">플레이어</a>
	<a href="javascript:show(7)">메뉴</a>
</nav>
<div id="settingArea">
	<form id="window" style="height: 100%;">
		<div>
			<button type="button" id="btnGetWindows">현재 위치 가져오기</button>
			<label><input type="checkbox" name="window_follow" /> 창 함께 이동</label>
		</div>
		<div id="fieldWindow">
			<fieldset id="fieldEditor">
				<legend>에디터</legend>
				<label><span>↦</span>: <input type="number" name="window_x" /></label>
				<label><span>↧</span>: <input type="number" name="window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="window_width" /></label>
				<label><span>↕</span>: <input type="number" name="window_height" /></label>
			</fieldset>
			<fieldset id="fieldViewer">
				<legend>미리보기</legend>
				<label><span>↦</span>: <input type="number" name="viewer_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="viewer_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="viewer_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="viewer_window_height" /></label>
			</fieldset>
			<fieldset id="fieldPlayer">
				<legend>플레이어</legend>
				<label><span>↦</span>: <input type="number" name="player_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="player_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="player_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="player_window_height" /></label>
				<br />
				<label><input type="checkbox" name="player_window_use" /> 위치 고정 사용</label>
			</fieldset>
		</div>
	</form>
	
	<form id="sync">
		<label>싱크 입력 시 <input type="number" name="sync_insert" min="0" />줄 아래로 이동</label><br />
		<label>싱크 수정 시 <input type="number" name="sync_update" min="0" />줄 아래로 이동</label><br />
		<label>싱크 가중치: <input type="number" name="sync_weight" />ms</label><br />
		<label>싱크 조절 단위: <input type="number" name="sync_unit" min="0" />ms</label><br />
		<label>재생 이동 단위: <input type="number" name="sync_move" min="0" />ms</label><br />
		<label>싱크 언어: <input type="text" name="sync_lang" /></label><br />
		<label>싱크 태그 형태: <input type="text" name="sync_preset" style="width: 400px;" /></label><br />
		<br />
		<label><input type="checkbox" name="sync_frame" /> 프레임 단위 싱크 보정</label><br />
		<p>※ 프레임 정보를 가져오지 못했을 경우 FPS를 기준으로 프레임 단위 싱크로 보정이 들어갑니다.<br />
			　가변 프레임 영상의 경우 문제가 생길 수 있습니다.
		</p>
		<br />
		<label>키프레임을 신뢰할 수 있는 영상에 대해 <input type="number" name="sync_kLimit" min="0" />ms 범위에서 화면 싱크를 키프레임에 맞도록 보정</label><br />
		<label><input type="checkbox" name="sync_kframe" /> 키프레임을 신뢰할 수 있는 영상에 대해 자동으로 화면 싱크 처리</label><br />
		<br />
		<label><input type="checkbox" name="sync_holds" /> 싱크 일괄 이동 시 다른 홀드에도 적용</label><br />
		<p>※ 블록지정 영역에 대한 일괄 싱크 입력에는 적용되지 않습니다.</p>
		<br />
		<label>화면 싱크 매니저 섬네일 생성 크기: <input type="number" name="sync_width"   min="1" />×<input type="number" name="sync_height"   min="1" /></label><br />
		<label>화면 싱크 매니저 섬네일 출력 크기: <input type="number" name="sync_uiWidth" min="1" />×<input type="number" name="sync_uiHeight" min="1" /></label><br />
	</form>
	
	<form id="cmd">
		<table style="width: calc(100% - 17px);">
			<cols>
				<col style="width: 8%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
			</cols>
			<thead>
				<tr>
					<th></th>
					<th>Ctrl</th>
					<th>Alt</th>
					<th>Ctrl+Alt</th>
					<th>Ctrl+Shift</th>
				</tr>
			</thead>
		</table>
		<div id="areaTableCommand">
			<table id="tableCommand">
				<cols>
					<col style="width: 8%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
				</cols>
				<tbody></tbody>
			</table>
		</div>
		<input type="hidden" id="inputCommandName" />
		<label>조합 <input type="text" id="inputCommandKey" readonly style="width: 100px;" /> (← 여기를 선택한 상태에서 단축키를 입력할 수 있습니다.)</label>
		<br />
		<textarea id="inputCommandFunc"></textarea>
		
		<fieldset id="areaFunctions" style="height: 364px; overflow-y: scroll;">
			<legend>사용자 정의 명령 함수 지원</legend>
			<ul>
				<li data-input="editor.getText()">
					<h4>editor.getText() → { text: '전체_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>전체 내용을 구해옵니다.</p>
				</li>
				<li data-input="editor.setText(text, [cursor, cursor])">
					<h4>editor.setText(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>전체 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.getLine()">
					<h4>editor.getLine() → { text: '현재_줄_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>커서(끝) 줄의 내용을 가져옵니다.</p>
				</li>
				<li data-input="editor.setLine(text, [cursor, cursor])">
					<h4>editor.setLine(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>커서(끝) 줄의 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.inputText(text, false)">
					<h4>editor.inputText(string '입력_텍스트', bool '커서_고정')</h4>
					<p>현재 커서 위치에 내용을 입력합니다.</p>
				</li> 
				<li data-input="editor.tagging('<i>', false)">
					<h4>editor.tagging(string '&lt;태그&gt;', bool '커서_위치부터')</h4>
					<p>커서가 있는 줄 전체, 혹은 커서 위치 이후 문자열에 태그를 입힙니다.</p>
				</li>
				<li data-input="editor.taggingRange('<u>')">
					<h4>editor.taggingRange(tag) { self.taggingRange(tag); };</h4>
					<p>tagging(string '&lt;태그&gt;', true)와 같은 동작입니다.</p>
				</li>
				<li data-input="editor.moveToSync()">
					<h4>editor.moveToSync()</h4>
					<p>현재 대사의 싱크를 재생합니다.<br />
						괄호 안에 가중치를 넣을 수 있습니다.
					</p>
				</li>
				<li data-input="editor.findSync()">
					<h4>editor.findSync()</h4>
					<p>현재 재생 중인 대사를 찾습니다.</p>
				</li>
				<li data-input="editor.deleteLine()">
					<h4>editor.deleteLine()</h4>
					<p>현재 줄을 삭제합니다.</p>
				</li>
				<li data-input="editor.insertSync()">
					<h4>editor.insertSync()</h4>
					<p>싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.insertSync(1)">
					<h4>editor.insertSync(1)</h4>
					<p>화면 싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.toggleSyncType()">
					<h4>editor.toggleSyncType()</h4>
					<p>기본 싱크 ↔ 화면 싱크 토글</p>
				</li>
				<li data-input="editor.removeSync()">
					<h4>editor.removeSync()</h4>
					<p>선택 영역 싱크를 삭제합니다.</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.playOrPause()">
					<h4>SmiEditor.PlayerAPI.playOrPause()</h4>
					<p>재생/일시정지</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.play()">
					<h4>SmiEditor.PlayerAPI.play()</h4>
					<p>재생</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.stop()">
					<h4>SmiEditor.PlayerAPI.stop()</h4>
					<p>정지</p>
				</li>
				<li data-input="newFile()">
					<h4>newFile()</h4>
					<p>새 파일</p>
				</li>
				<li data-input="openFile()">
					<h4>openFile()</h4>
					<p>파일 열기</p>
				</li>
				<li data-input="saveFile()">
					<h4>saveFile()</h4>
					<p>파일 저장하기</p>
				</li>
				<li data-input="saveFile(true)">
					<h4>saveFile(true)</h4>
					<p>다른 이름으로 저장하기</p>
				</li>
				<li data-input="openSetting()">
					<h4>openSetting()</h4>
					<p>설정창 열기</p>
				</li>
				<li data-input="openAddon('~~.html')">
					<h4>openAddon("~~.html")</h4>
					<p>직접 만든 부가기능 창을 열 수 있습니다.</p>
				</li>
			</ul>
		</fieldset>
	</form>
	
	<form id="ac">
		<p>
			줄 단위로 자동완성 문자열을 설정할 수 있습니다.<br />
			'|'를 이용해 입력값과 출력값이 다르게 설정할 수 있습니다. 
		</p>
		<br />
		<label>일반 문자열 (단어 입력 중 Ctrl+스페이스바 혹은 Tab키)<br />
			이곳에 입력한 값은 맞춤법 검사기 등을 사용할 때 예외처리에도 사용됩니다.
			<textarea name="autoComplete_0_1"></textarea>
		</label>
		<label>@
			<textarea name="autoComplete_50_1"></textarea>
		</label>
		<label>#
			<textarea name="autoComplete_51_1"></textarea>
		</label>
		<label>$
			<textarea name="autoComplete_52_1"></textarea>
		</label>
		<label>%
			<textarea name="autoComplete_53_1"></textarea>
		</label>
		<label>^
			<textarea name="autoComplete_54_1"></textarea>
		</label>
		<label>&
			<textarea name="autoComplete_55_1"></textarea>
		</label>
		<label>(
			<textarea name="autoComplete_57_1"></textarea>
		</label>
		<label>)
			<textarea name="autoComplete_48_1"></textarea>
		</label>
		<label>&lt;
			<textarea name="autoComplete_188_1"></textarea>
		</label>
		<label>&gt;
			<textarea name="autoComplete_190_1"></textarea>
		</label>
	</form>
	
	<form id="replace">
		<p>
			자막 파일 저장 시 자동치환 동작 설정입니다. 
		</p>
		<label><input type="checkbox" name="saveWithNormalize" /> 특수태그 정규화 자동 적용</label><br />
		<ol id="replaceList"></ol>
		<button type="button" class="add-replace">추가</button>
	</form>
	
	<form id="style">
		<div id="style_highlight_setting">
			<div>
				<label>문법 하이라이트:
					<select name="highlight_parser">
						<option value="">사용 안 함</option>
						<option value="SyncOnly">싱크만 구분</option>
						<option value="withoutSync">싱크 제외</option>
						<option value="full">전체</option>
					</select>
				</label><br />
				<label class="for-withoutSync"><span >　　싱크 투명도:</span>
					<input type="range" name="highlight_sync" min="0" max="1" step="0.01" />
				</label>
			</div>
			<div>
				<select name="highlight_style"></select><br />
				<span>
					<label><input type="checkbox" name="highlight_enter" /> <span>줄바꿈 표시</span></label>
					<label><input type="checkbox" name="highlight_color" /> <span>색상 미리보기</span></label>
				</span>
			</div>
		</div>
		<div style="float: left;">
			<label class="for-withoutSync"><span >커서 이동 시 스크롤 여백</span>
				<input type="number" style="width: 40px;" name="scrollMargin" step="0.5" min="0" />줄
			</label>
			<br />
			<label>UI 배율
				<select name="size">
					<option value="0.8" >80%</option>
					<option value="0.9" >90%</option>
					<option value="1"  >100%</option>
					<option value="1.1">110%</option>
					<option value="1.2">120%</option>
					<option value="1.3">130%</option>
					<option value="1.4">140%</option>
					<option value="1.5">150%</option>
					<option value="1.7">170%</option>
					<option value="2.0">200%</option>
					<option value="2.5">250%</option>
					<option value="3.0">300%</option>
					<option value="4.0">400%</option>
				</select>
			</label>
		</div>
		<div style="float: left; margin-left: 38px;">
			<label>스크롤바 노출 시간
				<input type="number" style="width: 40px;" name="scrollShow" step="0.5" min="0" />초<br />
				(※ 0초일 경우 기존 형태 스크롤바)
			</label>
		</div>
		<div style="clear: both;">
			<label><input type="checkbox" name="useTab" /> 탭 사용</label>
		</div>
		<div>
			<label><input type="checkbox" name="viewer_useAlign" /> 미리보기/ASS 변환 시 줄표로 시작할 경우 왼쪽 정렬</label>
		</div>
		<fieldset id="style_color">
			<legend>색 설정</legend>
			<fieldset id="style_color_preset">
				<legend>프리셋</legend>
				<ul></ul>
				<button type="button" id="btnAddPreset">현재값 프리셋에 추가</button>
			</fieldset>
			<div id="style_color_setting">
				<label><span>기본 배경 색      </span><input type="color" name="color_background" /></label><label><span>저장되지 않음 표시</span><input type="color" name="color_notSaved"   /></label><br />
				<label><span>탭/홀드 배경 색   </span><input type="color" name="color_selector"   /></label><label><span>설정/탭 테두리    </span><input type="color" name="color_tabBorder"  /></label><br />
				<label><span>비활성 탭/홀드 색 </span><input type="color" name="color_tab"        /></label><label><span>홀드/에디터 테두리</span><input type="color" name="color_border"     /></label><br />
				<label><span>에디터 배경 색    </span><input type="color" name="color_editor"     /></label><label><span>기본 글씨/커서 색 </span><input type="color" name="color_text"       /></label><br />
				<label><span>버튼 활성 색      </span><input type="color" name="color_hover"      /></label><label><span>화면 싱크 표시    </span><input type="color" name="color_syncBorder" /></label><br />
				<label><span>싱크 역전 표현    </span><input type="color" name="color_syncError"  /></label><label><span>싱크 중복 표현    </span><input type="color" name="color_syncEqual"  /></label><br />
			</div>
		</fieldset>
		<label id="areaNewFile">새 문서
		</label>
		<fieldset id="style_ass" style="display: block;">
			<legend>ASS 기본 스타일</legend>
			<div>
				<label><span>글꼴  </span><input type="text" name="defStyle_Fontname" />　</label>
				<label><span style="width: auto;">크기　</span><input type="number" name="defStyle_Fontsize" min="1" />px</label>
				<label><input type="checkbox" name="defStyle_Bold" checked="checked" /> 굵게</label>
			</div>
			<div>
				<label><span>외곽선</span><input type="color" name="defStyle_OutlineColour"   /><input type="text" class="color" /><input type="number" name="defStyle_Outline" />px</label>
			</div>
			<div>
				<label><span>그림자</span><input type="color" name="defStyle_BackColour"      /><input type="text" class="color" /><input type="number" name="defStyle_Shadow" />px</label>
			</div>
			<div>
				<label><span>좌우 여백</span><input type="number" name="defStyle_MarginL" min="0" />px</label> /
				<label><span>상하 여백</span><input type="number" name="defStyle_MarginV" min="0" />px</label>
			</div>
		</fieldset>
		<label for="taViewerCss">미리보기</label>
		<textarea id="taViewerCss" name="viewer_css" style="height: 300px;"></textarea>
	</form>
	
	<form id="player">
		<label>동영상 파일 확장자: <input type="text" name="player_exts" style="width: calc(100% - 140px);" /></label>
		<fieldset>
			<legend>플레이어: <select name="player_control_dll"></select></legend>
			<label>실행파일: <input type="text" name="player_control_what_path" style="width: calc(100% - 170px);" /></label><button type="button" id="btnPlayerPath" style="width: 100px;">찾아보기...</button><br />
			<label><input type="checkbox" name="player_control_what_withRun"  /> 프로그램 실행 시 플레이어 실행</label><br />
			<label><input type="checkbox" name="player_control_what_withExit" /> 프로그램 종료 시 플레이어 종료</label><br />
		</fieldset>
		<span>※ 다른 플레이어를 연동하고 싶으신 분은 "프로그램 폴더\bridge\readme.txt"를 참고하시기 바랍니다.</span>
	</form>
	
	<form id="menu">
		<ol id="menuList"></ol>
		<button type="button" class="add-menu">추가</button>
	</form>
</div>
<div id="applyArea">
	<button type="button" id="btnSubmit" accesskey="S">적용(<u>S</u>)</button>
	<button type="button" id="btnLoadDefault">기본값으로</button>
	<button type="button" id="btnLoadSetting">현재 설정으로</button>
</div>
</body>
</html>