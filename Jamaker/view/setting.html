<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>설정</title>
<script src="lib/jquery-3.2.1.min.js"></script>
<script src="lib/popup.js"></script>
<script src="lib/SmiEditor.js" type="module"></script>
<script>
windowName = "setting";

let styleColorAppendPreset = "";
_setColor = setColor;
setColor = function(color) {
	_setColor(color);

	let preset = styleColorAppendPreset;
	for (let name in color) {
		preset = preset.replaceAll("["+name+"]", color[name]);
	}
	document.getElementById("styleColorAppend").innerHTML = preset;
}

ready(() => {
	if (opener) {
		init();
    } else {
		setTimeout(() => {
			// iframe 기반인 경우 opener가 나중에 생김
			if (opener) {
				init();
			}
		}, 1);
	}
});
function init() {
	const setting = JSON.parse(JSON.stringify(opener.setting));
	const oSmiEditor = opener.SmiEditor;
	
	styleColorAppendPreset = document.getElementById("styleColorAppend").innerHTML;
	setColor(setting.color);
	SmiEditor.scrollShow = setting.scrollShow;
	
	let lastFocus = null;
	
	// 전역에서 접근 가능해야 함
	window.show = function(index) {
		let el;
		if (el = document.querySelector("#settingNav > a.selected"))     el.classList.remove("selected");
		if (el = document.querySelectorAll("#settingNav > a")[index])    el.classList.add   ("selected");
		if (el = document.querySelector("#settingArea > form.selected")) el.classList.remove("selected");
		opened = null;
		if (el = document.querySelectorAll("#settingArea > form")[index]) {
			el.classList.add("selected");
			opened = el.id;
		}
		// 지역변수 setting도 건드려야 함
		opener.setting.show = setting.show = index;
		lastFocus = null;
	}
	document.addEventListener("focus", function(e) {
		let input = e.target.closest("input");
		if (!input) input = e.target.closest("textarea");
		if (input) {
			lastFocus = input;
		}
		
	});
	document.addEventListener("keydown", (e) => {
		if (e.ctrlKey) {
			switch (e.key) {
				case "Tab": {
					// Ctrl+Tab 탭 전환
					let index = setting.show;
					if (e.shiftKey) {
						index = (index + 7) % 8;
					} else {
						index = (index + 1) % 8;
					}
					show(index);
					break;
				}
				case "1":
				case "2":
				case "3":
				case "4":
				case "5":
				case "6":
				case "7":
				case "8": {
					// Ctrl + 숫자 탭 전환
					show(Number(e.key) - 1);
				}
			}
		}
	});
	document.addEventListener("keyup", (e) => {
		if (e.altKey && e.key == "s") {
			// Alt+S 했을 땐 포커스 원위치
			lastFocus && lastFocus.focus();
		}
	});
	let opened = null;
	const submitFuncs = {};
	const refreshFuncs = {};
	let refreshTableCommand = () => {};
	
	const saved = {};
	function checkSaved(key, ok, no) {
		if (saved[key].status) {
			if (ok) ok();
			return;
		}
		confirm(saved[key].name + " 변경사항이 사라집니다.", ok, no);
	}
	function setSaved(key, status) {
		const item = saved[key];
		if (item) {
			item.status = status;
		}
	}
	function requestClose(keys) {
		if (!keys) {
			keys = [];
			for (let key in saved) {
				keys.push(key);
			}
		}
		if (keys.length) {
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				checkSaved(key, () => {
					requestClose(keys.slice(i + 1));
				});
				success = false;
				break;
			}
		} else {
			window.close();
		}
	}
	
	function refresh(formID, setting) {
		form = document.getElementById(formID);
		[...form.querySelectorAll("input")].concat([...form.querySelectorAll("textarea")]).forEach((el) => {
			let name = el.name;
			if (!name) return;
			
			if ((el.type == "text")
			 || (el.type == "number")
			 || (el.type == "color")
			 || (el.type == "range")
			 || (el.tagName == "TEXTAREA")
			) {
				if (name.indexOf("what") > 0) {
					name = name.replaceAll("what", setting.player.control.dll);
				}
				const value = eval(`setting['${ name.replaceAll("_", "']['") }']`);
				if (typeof value == "number" || typeof value == "string") {
					el.value = value;
				} else if (value && value.join) {
					el.value = value.join("\n");
				}
			} else if (el.type == "checkbox") {
				if (name.indexOf("what")) {
					name = name.replaceAll("what", setting.player.control.dll);
				}
				el.checked = eval(`setting['${ name.replaceAll("_", "']['") }']`);
			}
		});
		[...form.querySelectorAll("select")].forEach((el) => {
			const name = el.name;
			if (!name) return;
			
			// <option>이 아직 없을 수 있으므로 data로 넣어둠
			el.setAttribute("data-value", el.value = eval("setting." + name.replaceAll("_", ".")));
		});
	}
	
	const fieldEditor = document.getElementById("fieldEditor");
	const fieldViewer = document.getElementById("fieldViewer");
	const fieldPlayer = document.getElementById("fieldPlayer");
	
	const tableCommand = document.getElementById("tableCommand");
	const inputCommandName = document.getElementById("inputCommandName");
	const inputCommandKey  = document.getElementById("inputCommandKey" );
	const inputCommandFunc = document.getElementById("inputCommandFunc");
	
	{	// 창
		(refreshFuncs["window"] = (setting) => {
			refresh("window", setting);
			
			// 값에 맞춰 fieldset 이동
			const editor = setting.window;
			const viewer = setting.viewer.window;
			const player = setting.player.window;
			
			{
				const ecss = {};
				const vcss = {};
				const pcss = {};
				
				function setLeft(css, x) {
					css.left = x + 1;
				}
				function setRight(css, x) {
					css.width = (x - css.left - 2) + "%";
					css.left = css.left + "%";
				}
				function setTop(css, y) {
					css.top = y + 1;
				}
				function setBottom(css, y) {
					css.height = (y - css.top - 2) + "%";
					css.top = css.top + "%";
				}
				
				const targetXY = [
					[	{ p: editor.x                , f: (x) => { setLeft  (ecss, x); } }
					,	{ p: editor.x + editor.width , f: (x) => { setRight (ecss, x); } }
					,	{ p: viewer.x                , f: (x) => { setLeft  (vcss, x); } }
					,	{ p: viewer.x + viewer.width , f: (x) => { setRight (vcss, x); } }
					,	{ p: player.x                , f: (x) => { setLeft  (pcss, x); } }
					,	{ p: player.x + player.width , f: (x) => { setRight (pcss, x); } }
					]
				,	[	{ p: editor.y                , f: (y) => { setTop   (ecss, y); } }
					,	{ p: editor.y + editor.height, f: (y) => { setBottom(ecss, y); } }
					,	{ p: viewer.y                , f: (y) => { setTop   (vcss, y); } }
					,	{ p: viewer.y + viewer.height, f: (y) => { setBottom(vcss, y); } }
					,	{ p: player.y                , f: (y) => { setTop   (pcss, y); } }
					,	{ p: player.y + player.height, f: (y) => { setBottom(pcss, y); } }
					]
				];
				for (let xy = 0; xy < 2; xy++) {
					const targets = targetXY[xy];
					targets.sort((a, b) => { return a.p - b.p; });
					
					let last = [targets[0]];
					const ps = [last];
					for (let i = 1; i < targets.length; i++) {
						const curr = targets[i];
						if (curr.p == last[0].p) {
							last.push(curr);
						} else {
							last = [curr];
							ps.push(last);
						}
					}
					function getPos(i) {
						return 1 + ((98 / (ps.length - 1)) * i);
					}
					for (let i = 0; i < ps.length; i++) {
						const curr = ps[i];
						for (let j = 0; j < curr.length; j++) {
							curr[j].f(getPos(i));
						}
					}
				}
				for (key in ecss) {
					fieldEditor.style[key] = ecss[key];
					fieldViewer.style[key] = vcss[key];
					fieldPlayer.style[key] = pcss[key];
				}
			}
			
			setSaved("window"
				,  (JSON.stringify(setting.window) == JSON.stringify(opener.setting.window))
				&& (JSON.stringify(setting.viewer.window) == JSON.stringify(opener.setting.viewer.window))
				&& (JSON.stringify(setting.player.window) == JSON.stringify(opener.setting.player.window))
			);
		})(setting);
		
		submitFuncs["window"] = () => {
			setting.window.x             = Number(document.querySelector("input[name=window_x]"            ).value);
			setting.window.y             = Number(document.querySelector("input[name=window_y]"            ).value);
			setting.window.width         = Number(document.querySelector("input[name=window_width]"        ).value);
			setting.window.height        = Number(document.querySelector("input[name=window_height]"       ).value);
			setting.viewer.window.x      = Number(document.querySelector("input[name=viewer_window_x]"     ).value);
			setting.viewer.window.y      = Number(document.querySelector("input[name=viewer_window_y]"     ).value);
			setting.viewer.window.width  = Number(document.querySelector("input[name=viewer_window_width]" ).value);
			setting.viewer.window.height = Number(document.querySelector("input[name=viewer_window_height]").value);
			setting.player.window.x      = Number(document.querySelector("input[name=player_window_x]"     ).value);
			setting.player.window.y      = Number(document.querySelector("input[name=player_window_y]"     ).value);
			setting.player.window.width  = Number(document.querySelector("input[name=player_window_width]" ).value);
			setting.player.window.height = Number(document.querySelector("input[name=player_window_height]").value);
			setting.player.window.use    = document.querySelector("input[name=player_window_use]").checked;
			setting.window.follow        = document.querySelector("input[name=window_follow]").checked;
			opener.setSetting(setting);
			opener.saveSetting();
			opener.moveWindowsToSetting();
			setTimeout(() => { // 딜레이 줘야 정상적으로 계산됨
				opener.refreshPaddingBottom();
			}, 10);
			refreshFuncs["window"](setting);
		};
		
		document.getElementById("btnGetWindows").addEventListener("click", () => {
			opener.binder.getWindows(JSON.stringify(["editor", "viewer", "player"]));
		});
		// C#에서 Script("afterGetWindow", object[] { "editor", x, y, w, h });
		opener.afterGetWindow = (id, x, y, w, h) => {
			const name = (id == "editor")
			           ? "window"
			           : (id + "_window");
			document.querySelector(`input[name=${name}_x]`     ).value = x;
			document.querySelector(`input[name=${name}_y]`     ).value = y;
			document.querySelector(`input[name=${name}_width]` ).value = w;
			document.querySelector(`input[name=${name}_height]`).value = h;
		};
	}
	
	{	// 싱크
		(refreshFuncs["sync"] = (setting) => {
			refresh("sync", setting);
			setSaved("sync", (JSON.stringify(setting.sync) == JSON.stringify(opener.setting.sync)));
		})(setting);
		
		submitFuncs["sync"] = () => {
			const preset = document.querySelector("input[name=sync_preset]").value;
			
			// TODO: 프리셋 양식 오류 검증 필요?
			//       차라리 설정을 없앨까?
			// <Sync Start={sync}><P Class={lang}{type}>
			
			setting.sync.insert   = Number(document.querySelector("input[name=sync_insert]").value);
			setting.sync.update   = Number(document.querySelector("input[name=sync_update]").value);
			setting.sync.weight   = Number(document.querySelector("input[name=sync_weight]").value);
			setting.sync.unit     = Number(document.querySelector("input[name=sync_unit]"  ).value);
			setting.sync.move     = Number(document.querySelector("input[name=sync_move]"  ).value);
			setting.sync.lang     = document.querySelector("input[name=sync_lang]"  ).value;
			setting.sync.preset   = preset;
			setting.sync.frame    = document.querySelector("input[name=sync_frame]" ).checked;
			setting.sync.kframe   = document.querySelector("input[name=sync_kframe]").checked;
			setting.sync.kLimit   = Number(document.querySelector("input[name=sync_kLimit]").value);
			setting.sync.holds    = document.querySelector("input[name=sync_holds]").checked;
			setting.sync.width    = Number(document.querySelector("input[name=sync_width]" ).value);
			setting.sync.height   = Number(document.querySelector("input[name=sync_height]").value);
			setting.sync.uiWidth  = Number(document.querySelector("input[name=sync_uiWidth]" ).value);
			setting.sync.uiHeight = Number(document.querySelector("input[name=sync_uiHeight]").value);
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 단축키
		saved.cmd = { status: true, name: "단축키 설정" };
		
		refreshFuncs["cmd"] = (setting) => {
			if (setting == opener.setting) {
				checkSaved("cmd", () => {
					setSaved("cmd", true);
					inputCommandName.value = "";
					inputCommandKey .value = "";
					inputCommandFunc.value = "";
				});
				
			} else {
				confirm("현재 값은 복원할 수 없습니다.", () => {
					opener.setting.command = opener.deepCopyObj(setting.command);
					setSaved("cmd", true);
					inputCommandName.value = "";
					inputCommandKey .value = "";
					inputCommandFunc.value = "";
					refreshTableCommand();
					opener.setSetting(opener.setting);
					opener.saveSetting();
				});
			}
		};

		const tbody = tableCommand.querySelector("tbody");
		const withs = ["withCtrls", "withAlts", "withCtrlAlts", "withCtrlShifts"];
		const keys = "pqrstuvwxyz{ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=";
		const keyNames = ["F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12"].concat("ABCDEFGHIJKLMNOPQRSTUVWXYZ`1234567890-=".split(""));
		(refreshTableCommand = () => {
			tbody.innerHTML = "";
			for (let i = 0; i < keys.length; i++) {
				const key = keys[i];
				const keyName = (i < 12)
				              ? ("F" + (i + 1))
				              : key;
				const th = document.createElement("th");
				th.innerText = keyName;
				if (i < 12) {
					let func = setting.command.fn[key];
					if (!func || !func.trim()) {
						func = "";
						th.classList.add("not-used");
					} else {
						let label = func.trim();
						if (label.substring(0, 2) == "/*") {
							label = label.substring(2).split("*/")[0].trim();
						}
						th.classList.add("used");
						th.title = label;
					}
					th.setAttribute("data-name", `setting.command.fn['${ key }']`);
					th.setAttribute("data-key" , key);
					th.setAttribute("data-func", func);
				}
				const tr = document.createElement("tr");
				tr.classList.add("key-" + (keyName == '`' ? 'ㄹ' : (keyName == '=' ? '＝' : keyName)));
				tr.append(th);
				for (let j = 0; j < withs.length; j++) {
					const w = withs[j];
					const td = document.createElement("td");
					if (oSmiEditor[w].reserved.indexOf(key) >= 0) {
						let func = oSmiEditor[w][key];
						let label = func;
						if (label) {
							let type = typeof label;
							if (type == "string") {
								label = label.trim();
								if (label.substring(0, 2) == "/*") {
									label = label.substring(2).split("*/")[0].trim();
								}
							} else if (type == "function") {
								label = label.name;
							}
						} else {
							label = "시스템 단축키";
						}
						label = "예약: " + label;
						td.classList.add("fixed");
						td.innerText = label;
					} else {
						let func = setting.command[w][key];
						if (!func || !func.trim()) {
							func = "";
						} else {
							let label = func.trim();
							if (label.substring(0, 2) == "/*") {
								label = label.substring(2).split("*/")[0].trim();
							}
							td.classList.add("used");
							td.innerText = label;
						}
						td.setAttribute("data-name", `setting.command.${w}['${key}']`);
						td.setAttribute("data-with", j);
						td.setAttribute("data-key" , key);
						td.setAttribute("data-func", func);
					}
					tr.append(td);
				}
				tbody.append(tr);
			}
		})();
		
		tableCommand.addEventListener("click", (e) => {
			let td = e.target.closest("th.used");
			if (!td) td = e.target.closest("th.not-used");
			if (!td) td = e.target.closest("td:not(.fixed)");
			if (!td) return;
			
			const data = {
				name: td.getAttribute("data-name")
			,	with: td.getAttribute("data-with")
			,	key : td.getAttribute("data-key" )
			,	func: td.getAttribute("data-func")
			};
			const keyCode = data.key.charCodeAt();
			let keyName = (111 < keyCode && keyCode < 192) 
			            ? ("F" + (keyCode - 111)) // pqrstuvwxyz{ -> Fn
			            : data.key;
			switch (data.with) {
				case "0": {
					keyName = "Ctrl + " + keyName;
					break;
				}
				case "1": {
					keyName = "Alt + " + keyName;
					break;
				}
				case "2": {
					keyName = "Ctrl + Alt + " + keyName;
					break;
				}
				case "3": {
					keyName = "Ctrl + Shift + " + keyName;
					break;
				}
			}
			
			if (inputCommandKey.value == keyName) {
				// 현재 작업 중인 것
				return;
			}
			checkSaved("cmd", () => {
				setSaved("cmd", true);
				inputCommandName.value = data.name;
				inputCommandKey .value = keyName;
				inputCommandFunc.value = data.func;
			});
		});
		
		inputCommandKey.addEventListener("keydown", (e) => {
			e.preventDefault();
			e.stopPropagation();
			
			let keyName = e.key.toUpperCase();
			switch (keyName) {
				case '~': keyName = '`'; break;
				case '!': keyName = '1'; break;
				case '@': keyName = '2'; break;
				case '#': keyName = '3'; break;
				case '$': keyName = '4'; break;
				case '%': keyName = '5'; break;
				case '^': keyName = '6'; break;
				case '&': keyName = '7'; break;
				case '*': keyName = '8'; break;
				case '(': keyName = '9'; break;
				case ')': keyName = '0'; break;
				case '_': keyName = '-'; break;
				case '+': keyName = '='; break;
			}
			let key = keyName;
			if ((key[0] == "F") && (key.length > 1)) { // Fn -> pqrstuvwxyz{ 할당
				key = String.fromCharCode(Number(key.substring(1)) + 111);
			}
			// 사실 F12는 안 쓰려고 했어서 p~z로 잡았었는데, F12로 확장하느라 {까지 써버림...
			
			let name = "";
			let func = "";
			
			if (keys.indexOf(key) >= 0) {
				let command = keyName;
				const keyIndex = keyNames.indexOf(keyName);
				const selector = "tr.key-" + (keyName=='`' ? 'ㄹ' : (keyName=='=' ? '＝' : keyName));
				
				let w = null;
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							if (oSmiEditor.withCtrlShifts.reserved.indexOf(key) >= 0) {
								command = "Ctrl + Shift + 예약키";
							} else {
								func = tableCommand.querySelectorAll(`${selector} > td`)[3].getAttribute("data-func");
								name = `setting.command.withCtrlShifts["${key}"]`;
								command = "Ctrl + Shift + " + keyName;
							}
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							if (oSmiEditor.withCtrlAlts.reserved.indexOf(key) >= 0) {
								command = "Ctrl + Alt + 예약키";
							} else {
								func = tableCommand.querySelectorAll(`${selector} > td`)[2].getAttribute("data-func");
								name = `setting.command.withCtrlAlts["${key}"]`;
								command = "Ctrl + Alt + " + keyName;
							}
						} else {
							if (oSmiEditor.withCtrls.reserved.indexOf(key) >= 0) {
								command = "Ctrl + 예약키";
							} else {
								func = tableCommand.querySelectorAll(`${selector} > td`)[0].getAttribute("data-func");
								name = `setting.command.withCtrls["${key}"]`;
								command = "Ctrl + " + keyName;
							}
						}
					} else {
						if (e.altKey) {
							if (oSmiEditor.withAlts.reserved.indexOf(key) >= 0) {
								command = "Alt + 예약키";
							} else {
								func = tableCommand.querySelectorAll(`${selector} > td`)[1].getAttribute("data-func");
								name = `setting.command.withAlts["${key}"]`;
								command = "Alt + " + keyName;
							}
						} else {
							func = tableCommand.querySelectorAll(`${selector} > th`)[0].getAttribute("data-func");
							name = `setting.fn["${key}"]`;
						}
					}
				}
				
				if (inputCommandKey.value == command) {
					// 현재 작업 중인 것
					return;
				}
				document.getElementById("areaTableCommand").scrollTop = (keyIndex * 20);
				checkSaved("cmd", () => {
					inputCommandName.value = name;
					inputCommandKey .value = command;
					inputCommandFunc.value = func;
				});
				
			} else {
				if (e.shiftKey) {
					if (e.ctrlKey) {
						if (e.altKey) {
							
						} else {
							key = "Ctrl + Shift + ";
						}
					}
				} else {
					if (e.ctrlKey) {
						if (e.altKey) {
							key = "Ctrl + Alt + ";
						} else {
							key = "Ctrl + ";
						}
					} else {
						if (e.altKey) {
							key = "Alt + ";
						} else {
							
						}
					}
				}
			}
		});
		
		inputCommandFunc.addEventListener("input", (e) => {
			if (inputCommandKey.value.length > 1) { // 한 글자인 경우 단축키 조합 아님
				setSaved("cmd", false);
			} else {
				// 입력 차단
				inputCommandFunc.value;
			}
		});
		
		document.getElementById("areaFunctions").addEventListener("click", (e) => {
			const li = e.target.closest("li");
			if (li) {
				const func = inputCommandFunc.value;
				inputCommandFunc.value = (func ? func + "\n" : "") + li.getAttribute("data-input");
				if (inputCommandName.value) {
					setSaved("cmd", false);
				}
			}
		});
		
		submitFuncs["cmd"] = () => {
			const name = inputCommandName.value;
			if (name) {
				let func = inputCommandFunc.value;
				if (func.trim().length == 0) {
					func = " ";
				}
				eval(`${name} = func;`);
				setSaved("cmd", true);
				refreshTableCommand();
				opener.setSetting(setting);
				opener.saveSetting();
			}
		};
	}
	
	{	// 자동완성
		(refreshFuncs["ac"] = (setting) => {
			refresh("ac", setting);
			setSaved("ac", (JSON.stringify(setting.autoComplete) == JSON.stringify(opener.setting.autoComplete)));
		})(setting);
		
		submitFuncs["ac"] = () => {
			[...document.getElementById("ac").getElementsByTagName("textarea")].forEach((textarea) => {
				const name = `setting['${ textarea.name.replaceAll("_", "']['") }']`;
				let value = textarea.value;
				if (value) {
					value = value.split("\n");
				} else {
					value = [];
				}
				eval(`${name} = value`);
			});
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 자동치환
		saved.replace = { status: true, name: "자동치환 설정" };
		
		const replaceList = document.getElementById("replaceList");
		
		function appendReplace(item) {
			if (!item) {
				item = { from: "", to: "", use: true };
			}
			const li = document.createElement("li");
			let tmp;
			li.append(tmp = document.createElement("input" )); tmp.type = "text"; tmp.name = "from"; tmp.value = item.from;
			li.append("→")
			li.append(tmp = document.createElement("input" )); tmp.type = "text"; tmp.name = "to"  ; tmp.value = item.to  ;
			li.append(tmp = document.createElement("input" )); tmp.type = "checkbox"; tmp.name = "use"; tmp.checked = item.use;
			li.append(tmp = document.createElement("button")); tmp.type = "button"; tmp.classList.add("prev"  ); tmp.innerText = "∧";
			li.append(tmp = document.createElement("button")); tmp.type = "button"; tmp.classList.add("next"  ); tmp.innerText = "∨";
			li.append(tmp = document.createElement("button")); tmp.type = "button"; tmp.classList.add("remove"); tmp.innerText = "✕";
			replaceList.append(li);
		}
		(refreshFuncs["replace"] = (setting) => {
			refresh("replace", setting);
			replaceList.innerHTML = "";
			for (let i = 0; i < setting.replace.length; i++) {
				appendReplace(setting.replace[i]);
			}
			setSaved("replace"
				,  (setting.saveWithNormalize == opener.setting.saveWithNormalize)
				&& (JSON.stringify(setting.command) == JSON.stringify(opener.setting.command))
			);
		})(setting);
		
		document.querySelector("#replace > .add-replace").addEventListener("click", () => {
			appendReplace();
			setSaved("replace", false);
		});
		
		replaceList.addEventListener("click", (e) => {
			let btn;
			if (btn = e.target.closest("li > button.prev")) {
				const li = btn.parentNode;
				const prev = li.previousSibling;
				if (prev) {
					prev.before(li);
					setSaved("replace", false);
				}
			}
			
			if (btn = e.target.closest("li > button.next")) {
				const li = btn.parentNode;
				const next = li.nextSibling;
				if (next) {
					next.after(li);
					setSaved("replace", false);
				}
			}
			
			if (btn = e.target.closest("li > button.remove")) {
				const li = btn.parentNode;
				confirm("삭제하시겠습니까?", function() {
					li.remove();
					setSaved("replace", false);
				});
			}
		});
		
		submitFuncs["replace"] = () => {
			const replaces = [];
			
			[...replaceList.getElementsByTagName("li")].forEach((li) => {
				const item = {
						from: li.querySelector("input[name=from]").value
					,	to  : li.querySelector("input[name=to]").value
					,	use : li.querySelector("input[name=use]").checked
				};
				if (item.from && item.to) {
					replaces.push(item);
				}
			});
			
			setting.saveWithNormalize = document.querySelector("input[name=saveWithNormalize]").checked;
			setting.replace = replaces;
			setSaved("replace", true);
			opener.setSetting(setting);
			opener.saveSetting();
		};
	}
	
	{	// 스타일
		saved.style = { status: true, name: "스타일 설정" };
		
		const presetUl = document.querySelector("#style_color_preset ul");
		presetUl.addEventListener("click", (e) => {
			let el;
			if (el = e.target.closest("li span")) {
				const color = setting.colorPreset[el.parentNode.getAttribute("data-key")];
				for (let name in color) {
					document.querySelector(`input[name=color_${name}]`).value = color[name];
				}
			}
			if (el = e.target.closest("li button")) {
				const key = el.parentNode.getAttribute("data-key");
				confirm("삭제하시겠습니까?", () => {
					delete(setting.colorPreset[key]);
					refreshPreset(setting);
				});
			}
		});
		document.getElementById("btnAddPreset").addEventListener("click", () => {
			const name = prompt("프리셋 이름을 입력하세요.");
			if (!name) {
				alert("이름이 입력되지 않았습니다.");
				return;
			}
			const color = {};
			color.background = document.querySelector("input[name=color_background]").value;
			color.selector   = document.querySelector("input[name=color_selector]"  ).value;
			color.border     = document.querySelector("input[name=color_border]"    ).value;
			color.tab        = document.querySelector("input[name=color_tab]"       ).value;
			color.tabBorder  = document.querySelector("input[name=color_tabBorder]" ).value;
			color.editor     = document.querySelector("input[name=color_editor]"    ).value;
			color.text       = document.querySelector("input[name=color_text]"      ).value;
			color.hover      = document.querySelector("input[name=color_hover]"     ).value;
			color.notSaved   = document.querySelector("input[name=color_notSaved]"  ).value;
			color.syncBorder = document.querySelector("input[name=color_syncBorder]").value;
			color.syncError  = document.querySelector("input[name=color_syncError]" ).value;
			color.syncEqual  = document.querySelector("input[name=color_syncEqual]" ).value;
			setting.colorPreset[name] = color;
			refreshPreset(setting);
		});
		function refreshPreset(setting) {
			presetUl.innerHTML = "";
			for (let key in setting.colorPreset) {
				const li = document.createElement("li");
				li.setAttribute("data-key", key);
				let tmp;
				li.append(tmp = document.createElement("span")); tmp.innerText = key;
				li.append(tmp = document.createElement("button")); tmp.innerText = "×"; tmp.type = "button";
				presetUl.append(li);
			}
		}
		
		function refreshHighlight() {
			SmiEditor.setHighlight({
					parser: document.querySelector("select[name=highlight_parser]").value
				,	style : document.querySelector("select[name=highlight_style]" ).value
				,	enter : document.querySelector("input[name=highlight_enter]").checked
				,	color : document.querySelector("input[name=highlight_color]").checked
				,	sync  : Number(document.querySelector("input[name=highlight_sync]").value)
			}, [editorNewFile]);
		}
		const editorNewFile = new SmiEditor();
		document.getElementById("areaNewFile").append(editorNewFile.area);
		{	// textarea resize
			editorNewFile.area.style.height = "400px";
			let resizeNewFile = false;
			editorNewFile.input.name = "newFile";
			editorNewFile.input.style.height = "398px";
			editorNewFile.input.addEventListener("mousedown", () => {
				resizeNewFile = true;
			});
			document.addEventListener("mousemove", () => {
				if (!resizeNewFile) return;
				editorNewFile.area.style.height = `${ editorNewFile.input.offsetHeight + 2 }px`;
			});
			document.addEventListener("mouseup", () => {
				resizeNewFile = false;
			});
		}
		
		[document.querySelector("input[name=defStyle_OutlineColour]"), document.querySelector("input[name=defStyle_BackColour]")].forEach((el) => {
			el.nextSibling.value = el.value.toUpperCase();
			el.addEventListener("input", () => {
				el.nextSibling.value = el.value.toUpperCase();
			});
		});
		document.addEventListener("input", (e) => {
			const input = e.target.closest("input.color");
			if (!input) return;

			const color = input.value;
			if (color.startsWith("#") && color.length == 7) {
				if (isFinite("0x" + color.substring(1))) {
					input.previousSibling.value = color;
				} else {
					return;
				}
			} else {
				return;
			}
		});
		
		let selectParser = document.querySelector("select[name=highlight_parser]");
		let selectStyle  = document.querySelector("select[name=highlight_style]" );
		let selectSize   = document.querySelector("select[name=size]");
		if (opener.highlights) {
			for (let i = 0; i < opener.highlights.length; i++) {
				const item = opener.highlights[i].trim();
				if (item.length) {
					const split = item.split(":");
					const value = split[0].trim();
					let name = (split.length > 1) ? split[1].trim() : value;
					if (name.indexOf("?")) name = name.split("?")[0];
					
					const opt = document.createElement("option");
					opt.value = value;
					opt.innerText = name;
					selectStyle.append(opt);
				}
			}
			selectParser.value = selectParser.dataset.value;
			selectStyle .value = selectStyle .dataset.value;
		}
		
		(refreshFuncs["style"] = (setting) => {
			refresh("style", setting);
			refreshPreset(setting);
			setSaved("style"
				,  (setting.useTab == opener.setting.useTab)
				&& (setting.viewer.useAlign == opener.setting.viewer.useAlign)
				&& (JSON.stringify(setting.highlight  ) == JSON.stringify(opener.setting.highlight  ))
				&& (JSON.stringify(setting.color      ) == JSON.stringify(opener.setting.color      ))
				&& (JSON.stringify(setting.colorPreset) == JSON.stringify(opener.setting.colorPreset))
				&& (JSON.stringify(setting.newFile    ) == JSON.stringify(opener.setting.newFile    ))
				&& (JSON.stringify(setting.viewer.css ) == JSON.stringify(opener.setting.viewer.css ))
			);
			editorNewFile.render();
			refreshHighlight();
		})(setting);
		
		document.addEventListener("change", (e) => {
			let el = e.target.closest("select[name=highlight_parser]");
			if (!el) el = e.target.closest("select[name=highlight_style]");
			if (!el) el = e.target.closest("input[name=highlight_enter]");
			if (!el) el = e.target.closest("input[name=highlight_color]");
			if (el) {
				refreshHighlight();
			}
		});
		selectParser.addEventListener("change", () => {
			const shs = document.getElementById("style_highlight_setting");
			const inputs = [].concat(shs.querySelectorAll("input")).concat(shs.querySelectorAll("select[name=highlight_style]"));
			if (selectParser.value) {
				shs.classList.remove("disabled");
				inputs.forEach((el) => { el.disabled = false; });
			} else {
				shs.classList.add("disabled");
				inputs.forEach((el) => { el.disabled = true; });
			}
		});
		selectParser.dispatchEvent(new Event("change", { bubbles: true }));
		
		document.getElementById("style").addEventListener("input", () => {
			setSaved("style", false);
		});
		
		submitFuncs["style"] = () => {
			setting.size             = document.querySelector("select[name=size]").value;
			setting.useTab           = document.querySelector("input[name=useTab]").checked;
			
			setting.highlight.parser = document.querySelector("select[name=highlight_parser]").value;
			setting.highlight.style  = document.querySelector("select[name=highlight_style]").value;
			setting.highlight.enter  = document.querySelector("input[name=highlight_enter]").checked;
			setting.highlight.color  = document.querySelector("input[name=highlight_color]").checked;
			setting.highlight.sync   = Number(document.querySelector("input[name=highlight_sync]").value);
			
			setting.scrollMargin     = Number(document.querySelector("input[name=scrollMargin]").value);
			setting.scrollShow       = Number(document.querySelector("input[name=scrollShow]").value);
			
			setting.viewer.useAlign  = document.querySelector("input[name=viewer_useAlign]").checked;
			setting.viewer.css       = document.querySelector("textarea[name=viewer_css]").value;
			
			setting.newFile          = document.querySelector("textarea[name=newFile]"   ).value;
			
			setting.color.background = document.querySelector("input[name=color_background]").value;
			setting.color.selector   = document.querySelector("input[name=color_selector]"  ).value;
			setting.color.border     = document.querySelector("input[name=color_border]"    ).value;
			setting.color.tab        = document.querySelector("input[name=color_tab]"       ).value;
			setting.color.tabBorder  = document.querySelector("input[name=color_tabBorder]" ).value;
			setting.color.editor     = document.querySelector("input[name=color_editor]"    ).value;
			setting.color.text       = document.querySelector("input[name=color_text]"      ).value;
			setting.color.hover      = document.querySelector("input[name=color_hover]"     ).value;
			setting.color.notSaved   = document.querySelector("input[name=color_notSaved]"  ).value;
			setting.color.syncBorder = document.querySelector("input[name=color_syncBorder]").value;
			setting.color.syncError  = document.querySelector("input[name=color_syncError]" ).value;
			setting.color.syncEqual  = document.querySelector("input[name=color_syncEqual]" ).value;
			
			const defaultHolds = [];
			{
				for (let t = 0; t < opener.tabs.length; t++) {
					const tab = opener.tabs[t];
					for (let h = 0; h < tab.holds.length; h++) {
						const hold = tab.holds[h];
						if (!hold.style) {
							// 기본 스타일이면 적용
							defaultHolds.push(hold);
						} else {
							if (opener.SmiFile.toSaveStyle(hold.style, setting.defStyle) == "") {
								// 기본 스타일이면 적용
								defaultHolds.push(hold);
							}
						}
					}
				}
			}
			setting.defStyle.Fontname        = document.querySelector("input[name=defStyle_Fontname]"     ).value;
			setting.defStyle.Fontsize = Number(document.querySelector("input[name=defStyle_Fontsize]"     ).value);
			setting.defStyle.Bold            = document.querySelector("input[name=defStyle_Bold]"         ).checked;
			setting.defStyle.OutlineColour   = document.querySelector("input[name=defStyle_OutlineColour]").value;
			setting.defStyle.Outline  = Number(document.querySelector("input[name=defStyle_Outline]"      ).value);
			setting.defStyle.BackColour      = document.querySelector("input[name=defStyle_BackColour]"   ).value;
			setting.defStyle.Shadow   = Number(document.querySelector("input[name=defStyle_Shadow]"       ).value);
			setting.defStyle.MarginL = setting.defStyle.MarginR = Number(document.querySelector("input[name=defStyle_MarginL]").value);
			setting.defStyle.MarginV  = Number(document.querySelector("input[name=defStyle_MarginV]"      ).value);
			if (!setting.defStyle.Fontname) {
				document.querySelector("input[name=defStyle_Fontname]").value = setting.defStyle.Fontname = "맑은 고딕";
			}
			setting.viewer.size = setting.defStyle.Fontsize / 80 * 18;
			
			setSaved("style", true);
			opener.setSetting(setting);
			opener.saveSetting();
			setColor(setting.color);
			SmiEditor.scrollShow = setting.scrollShow;
			
			for (let i = 0; i < defaultHolds.length; i++) {
				defaultHolds[i].setStyle(JSON.parse(JSON.stringify(setting.defStyle)));
			}
		};
	}
	
	{	// 플레이어
		(refreshFuncs["player"] = (setting) => {
			refresh("player", setting);
			setSaved("player"
				,  (setting.exts == opener.setting.exts)
				&& (JSON.stringify(setting.player.control) == JSON.stringify(opener.setting.player.control))
			);
		})(setting);
		
		const select = document.querySelector("select[name=player_control_dll]");
		if (opener.playerDlls) {
			for (let i = 0; i < opener.playerDlls.length; i++) {
				const dll = opener.playerDlls[i].split(":");
				const opt = document.createElement("option");
				opt.value = dll[0].trim();
				opt.innerText = dll[1].trim();
				select.append(opt);
            }
            select.value = select.dataset.value;
		}
		select.addEventListener("change", (e) => {
			const dll = select.value;
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = {
						path: ""
					,	withRun: true
					,	withExit: true
				};
			}
			document.querySelector("input[name=player_control_what_path]"    ).value = dllSetting.path;
			document.querySelector("input[name=player_control_what_withRun]" ).checked = dllSetting.withRun;
			document.querySelector("input[name=player_control_what_withExit]").checked = dllSetting.withExit;
		});
		
		document.getElementById("btnPlayerPath").addEventListener("click", () => {
			opener.binder.selectPlayerPath();
		});
		opener.afterSelectPlayerPath = (path) => {
			document.querySelector("input[name=player_control_what_path]").value = path;
		};
		
		submitFuncs["player"] = () => {
			setting.player.exts = document.querySelector("input[name=player_exts]").value;
			const dll = setting.player.control.dll = select.value;
			let dllSetting = setting.player.control[dll];
			if (!dllSetting) {
				dllSetting = setting.player.control[dll] = {};
			}
			dllSetting.path     = document.querySelector("input[name=player_control_what_path]"    ).value;
			dllSetting.withRun  = document.querySelector("input[name=player_control_what_withRun]" ).checked;
			dllSetting.withExit = document.querySelector("input[name=player_control_what_withExit]").checked;
			opener.setSetting(setting);
			opener.saveSetting();
			opener.binder.setVideoExts(setting.player.exts);
		};
	}
	
	{	// 메뉴
		saved.menu = { status: true, name: "메뉴 설정" };
		
		const menuList = document.getElementById("menuList");
		
		function appendMenu(menus) {
			if (!menus) menus = [""];
			
			const fieldset = document.createElement("fieldset");
			const legend = document.createElement("legend");
			{	let tmp = document.createElement("input");
				tmp.type = "text";
				tmp.value = menus[0];
				legend.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("prev");
				tmp.innerText = "∧";
				legend.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("next");
				tmp.innerText = "∨";
				legend.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("remove");
				tmp.innerText = "✕";
				legend.append(tmp);
			}
			fieldset.append(legend);
			
			const ol = document.createElement("ol");
			fieldset.append(ol);
			
			for (let j = 1; j < menus.length; j++) {
				const menu = menus[j].split("|");
				const name = menu[0];
				const func = menu.slice(1).join("|");
				appendSubMenu(ol, name, func);
			}
			
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("add-menu");
				tmp.innerText = "추가";
				fieldset.append(tmp);
			}
			
			const li = document.createElement("li");
			li.append(fieldset);
			menuList.append(li);
			return li;
		}
		function appendSubMenu(ol, name, func) {
			if (!ol) return;
			if (!name) name = "";
			if (!func) func = "";
			const li = document.createElement("li");
			{	let tmp = document.createElement("input");
				tmp.type = "text";
				tmp.placeholder = "이름을 비우면 구분선이 됩니다.";
				tmp.value = name;
				li.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("prev");
				tmp.innerText = "∧";
				li.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("next");
				tmp.innerText = "∨";
				li.append(tmp);
			}
			{	let tmp = document.createElement("input");
				tmp.type = "text";
				tmp.classList.add("menu-func");
				tmp.value = func;
				li.append(tmp);
			}
			{	let tmp = document.createElement("button");
				tmp.type = "button";
				tmp.classList.add("remove");
				tmp.innerText = "✕";
				li.append(tmp);
			}
			ol.append(li);
			return li;
		}
		(refreshFuncs["menu"] = (setting) => {
			menuList.innerHTML = "";
			for (let i = 0; i < setting.menu.length; i++) {
				appendMenu(setting.menu[i]);
			}
			setSaved("menu", (JSON.stringify(setting.menu) == JSON.stringify(opener.setting.menu)));
		})(setting);
		
		const menu = document.getElementById("menu");
		menu.addEventListener("click", (e) => {
			let el;
			if (el = e.target.closest(".add-menu")) {
				if (el.parentNode == menu) {
					appendMenu().querySelector("input").focus();
					setSaved("menu", false);
				} else {
					appendSubMenu(el.parentNode.querySelector("ol")).querySelector("input").focus();
					setSaved("menu", false);
				}
				return;
			}
			if (el = e.target.closest("legend > button.prev")) {
				const menu = el.parentNode.parentNode.parentNode;
				const prev = menu.previousSibling;
				if (prev) {
					prev.before(menu);
					setSaved("menu", false);
					el.focus();
				}
				return;
			}
			if (el = e.target.closest("legend > button.next")) {
				const menu = el.parentNode.parentNode.parentNode;
				const next = menu.nextSibling;
				if (next) {
					next.after(menu);
					setSaved("menu", false);
					el.focus();
				}
				return;
			}
			if (el = e.target.closest("legend > button.remove")) {
				const menu = el.parentNode.parentNode.parentNode;
				confirm("삭제하시겠습니까?", () => {
					menu.remove();
					setSaved("menu", false);
				});
				return;
			}
			if (el = e.target.closest("ol > li > button.prev")) {
				const subMenu = el.parentNode;
				const prev = subMenu.previousSibling;
				if (prev) {
					prev.before(subMenu);
					setSaved("menu", false);
					el.focus();
				}
				return;
			}
			if (el = e.target.closest("ol > li > button.next")) {
				const subMenu = el.parentNode;
				const next = subMenu.nextSibling;
				if (next) {
					next.after(subMenu);
					setSaved("menu", false);
					el.focus();
				}
				return;
			}
			if (el = e.target.closest("ol > li > button.remove")) {
				const subMenu = el.parentNode;
				confirm("삭제하시겠습니까?", () => {
					subMenu.remove();
					setSaved("menu", false);
				});
				return;
			}
		});
		
		submitFuncs["menu"] = () => {
			const menus = [];
			
			[...menuList.querySelectorAll("fieldset")].forEach((fieldset) => {
				const menu = [fieldset.querySelector("legend > input").value];
				
				[...fieldset.querySelectorAll("li")].forEach((li) => {
					const inputs = li.querySelectorAll("input");
					menu.push(inputs[0].value + "|" + inputs[1].value);
				});
				menus.push(menu);
			});
			
			setting.menu = menus;
			setSaved("menu", true);
			opener.setSetting(setting);
			opener.saveSetting();
			
			// Alt 단축키 바뀌었을 수 있으므로 단축키 설정 새로고침
			refreshTableCommand();
		};
	}
	
	document.getElementById("btnLoadSetting").addEventListener("click", () => {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(setting);
		}
	});
	
	document.getElementById("btnLoadDefault").addEventListener("click", () => {
		const refreshFunc = refreshFuncs[opened];
		if (refreshFunc) {
			refreshFunc(opener.DEFAULT_SETTING);
		}
	});
	
	document.getElementById("btnSubmit").addEventListener("click", () => {
		const submitFunc = submitFuncs[opened];
		if (submitFunc) submitFunc();
	});
	
	[...document.getElementsByTagName("form")].forEach((form) => {
		form.novalidate = true;
		form.onsubmit = function(e) {
			e.preventDefault();
			submitFuncs[form.id]();
		};
		const btn = document.createElement("button");
		btn.type = "submit";
		btn.style.display = "none";
		form.append(btn);
	});
	
	show(opener.setting.show ? opener.setting.show : 0);
};
</script>
<style>
* {
	font-size: 14px;
}
textarea {
	width: 100%;
	height: 100px;
	font-family: '돋움체'; /* 여기선 고정폭 문자 써야 할 듯 */
	resize: vertical;
}

input[type=number] { width: 50px; }

fieldset {
	padding: 8px;
	margin: 8px 0;
}

fieldset li { margin-bottom: 2px; }

/* 기본 틀 */
#settingNav {
	position: fixed;
	top: 0;
	left: 8px;
	right: 8px;
	height: 40px;
	padding-top: 8px;
	border-bottom: 1px solid #888;
}
#settingArea {
	position: fixed;
	top: 40px;
	left: 8px;
	right: 8px;
	bottom: 48px;
	overflow-y: scroll;
	border: 1px solid #888;
	border-top: 0;
	padding: 8px;
}
#applyArea {
	position: fixed;
	left: 0;
	right: 0;
	bottom: 0;
	height: 48px;
}
#btnLoadSetting,
#btnLoadDefault,
#btnSubmit {
	float: right;
	margin: 8px 8px 8px 0;
	min-width: 100px;
	padding: 4px;
	line-height: 22px;
	font-size: 16px;
}

/* 탭 UI */
#settingNav > a {
	display: block;
	float: left;
	margin: 0 -1px -1px 0;
	border: 1px solid #888;
	border-radius: 6px 6px 0 0;
	font-size: 16px;
	text-decoration: none;
	height: 32px;
	line-height: 32px;
	padding: 0 8px;
}
#settingArea > form {
	display: none;
}
#settingArea > form.selected {
	display: block;
}

/* 창 */
#btnGetWindows {
	padding: 4px;
}
#fieldWindow {
	width: 100%;
	height: calc(100% - 50px);
	position: relative;
}
#fieldWindow > fieldset {
	position: absolute;
}
#fieldWindow > fieldset:hover {
	z-index: 9999;
}
#fieldWindow > fieldset span {
	display: inline-block;
	width: 16px;
	text-align: center;
}

/* 단축키 */
#areaTableCommand {
	height: 210px;
	overflow-y: scroll;
	border-bottom: 1px solid #aaa;
	margin-bottom: 4px;
}
#tableCommand {
	width: 100%;
}
#tableCommand tr {
	height: 20px;
}
#tableCommand th.used,
#tableCommand th.not-used {
	cursor: pointer;
}
#tableCommand td {
	height: 20px;
	overflow: hidden;
	white-space: nowrap;
	text-overflow: ellipsis;
	cursor: pointer;
}
#tableCommand td.fixed {
	cursor: default;
}
#areaFunctions li {
	margin: 8px 0;
	border: 1px solid #ddd;
	border-radius: 8px;
	padding: 4px;
	cursor: pointer;
}
#areaFunctions h4 {
	margin-bottom: 4px;
}

/* 자동치환, 메뉴 */
#replaceList { margin: 8px 0 2px; }
#replaceList input[type=text] { width: calc(50% - 40px); }
#replaceList input[type=checkbox] { width: 17px; }
#replace > button.add-replace { width: 100%; margin-top: 8px; }

#replaceList button,
#menu button { width: 16px; }
#menu input,
#menu button.add-menu { width: 200px; }
#menu input.menu-func { width: calc(100% - 250px); margin-left: 2px; }
#menu > button.add-menu { width: 216px; margin-top: 8px; }

#replaceList button,
fieldset legend button,
fieldset ol button,
#btnPlayerPath { border-left-width: 0; }
#replace input + button { border-left-width: 1px; }

/* 스타일 */
#style_highlight_setting > div {
	float: left;
	margin-right: 4px;
}
#style_highlight_setting:after {
	display: block;
	content: ""; 
	clear: both;
	margin-bottom: 8px;
}
#style_highlight_setting label {
	margin-right: 8px;
}
#style_highlight_setting.disabled label > span {
	opacity: 0.5;
}
#style_highlight_setting select[name=highlight_parser],
#style_highlight_setting input[name=highlight_sync] {
	width: 101px;
}
#style_color_preset {
	float: left;
	width: 200px;
	height: 146px;
}
#style_color_preset ul {
	overflow-y: scroll;
	height: calc(100% - 18px);
}
#style_color_preset li {
	border: 1px solid #888;
	cursor: pointer;
	width: 100%;
	height: 20px;
	line-height: 20px;
}
#style_color_preset li:hover {
	background: #fff;
}
#style_color_preset li span {
	display: block;
	width: calc(100% - 16px);
	height: 18px;
	float: left;
	white-space: nowrap;
	overflow: hidden;
}
#style_color_preset li button {
	display: block;
	width: 16px;
	height: 18px;
	float: right;
	border-width: 0 0 0 1px;
}
#btnAddPreset {
	width: 100%;
}
#style_color_setting {
	float: left;
}
#style_color_setting label {
	display: inline-block;
	margin-left: 10px;
}
#style_color_setting span {
	display: inline-block;
	width: 140px;
}
#style_color:after {
	display: block;
	content: "";
	clear: both;
}
/* 새 문서 에디터 */
#areaNewFile .hold > .col-sync {
	display: none;
}
#areaNewFile .hold > .input {
	left: 0;
	height: 100%;
}
#areaNewFile .highlight-textarea {
	border: 1px solid #888;
}
#areaNewFile .highlight-textarea > textarea {
	resize: vertical;
}
/* ASS 기본 스타일 */
#style_ass span {
	display: inline-block;
	width: 70px;
}
#style_ass input[type=text],
#style_ass input[type=number],
#style_ass input[type=color] {
	height: 22px;
}
#style_ass input[type=text].color {
	width: 60px;
}

body.classic-scrollbar ::-webkit-scrollbar,
body.classic-scrollbar ::-webkit-scrollbar-button { width: calc(20px * 0.8 + 1px); height: calc(20px * 0.8 + 1px); }
body.classic-scrollbar ::-webkit-scrollbar-button:end { background-position-y: calc(20px * 0.8 + 1px); }
body.classic-scrollbar ::-webkit-scrollbar-button:horizontal { background-position-x: calc(20px * 0.8 + 1px); }
body:not(.classic-scrollbar) ::-webkit-scrollbar-thumb { border-radius: calc(20px * 0.5); border: calc(20px * 0.2) solid transparent; }

.input ::-webkit-scrollbar-thumb:hover { background-color: #aaaaaa; }
.input .scrolling::-webkit-scrollbar-thumb { background-color: #c1c1c1; }
.input .scrolling::-webkit-scrollbar-corner { background: #dddddd; }

</style>
<style id="styleColor"></style>
<style id="styleColorAppend">
body {
	background: [selector];
}
#settingArea fieldset {
	border-color: [tabBorder];
}

#settingArea,
#applyArea button {
	background: [background];
	color: [text];
}
#settingNav > a {
	background: [tab];
	color: [text];
}
#settingNav > a.selected {
	background: [background];
	border-bottom-color: [background];
}
#settingNav > a:hover {
	background: [background];
}

#fieldWindow > fieldset:hover {
	background: [hover]88;
}
#tableCommand {
	color: #000;
}
#tableCommand th {
	background: #e1e1e1;
}
#tableCommand th.not-used {
	background: #fff;
}
#tableCommand th.not-used:hover,
#tableCommand td:hover {
	background: #ff8;
}
#tableCommand td.fixed {
	background: #f88;
}
#tableCommand th.used,
#tableCommand td.used {
	background: #8ff;
}
#tableCommand th.used:hover,
#tableCommand td.used:hover {
	background: #cfc;
}
#areaFunctions li {
	border-color: [tab];
}
#areaFunctions li:hover {
	/*
	background: #ffd;
	*/
	background: [hover];
}

#style_color_preset li {
	border-color: [tabBorder];
}
#style_color_preset li:hover {
	background: [hover];
}
#areaNewFile .highlight-textarea {
	border-color: [tabBorder];
}
</style>
</head>
<body>

<nav id="settingNav">
	<a href="javascript:show(0)">창 배치</a>
	<a href="javascript:show(1)">싱크</a>
	<a href="javascript:show(2)">단축키</a>
	<a href="javascript:show(3)">자동완성</a>
	<a href="javascript:show(4)">자동치환</a>
	<a href="javascript:show(5)">스타일</a>
	<a href="javascript:show(6)">플레이어</a>
	<a href="javascript:show(7)">메뉴</a>
</nav>
<div id="settingArea">
	<form id="window" style="height: 100%;">
		<div>
			<button type="button" id="btnGetWindows">현재 위치 가져오기</button>
			<label><input type="checkbox" name="window_follow" /> 창 함께 이동</label>
		</div>
		<div id="fieldWindow">
			<fieldset id="fieldEditor">
				<legend>에디터</legend>
				<label><span>↦</span>: <input type="number" name="window_x" /></label>
				<label><span>↧</span>: <input type="number" name="window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="window_width" /></label>
				<label><span>↕</span>: <input type="number" name="window_height" /></label>
			</fieldset>
			<fieldset id="fieldViewer">
				<legend>미리보기</legend>
				<label><span>↦</span>: <input type="number" name="viewer_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="viewer_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="viewer_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="viewer_window_height" /></label>
			</fieldset>
			<fieldset id="fieldPlayer">
				<legend>플레이어</legend>
				<label><span>↦</span>: <input type="number" name="player_window_x" /></label>
				<label><span>↧</span>: <input type="number" name="player_window_y" /></label>
				<br />
				<label><span>↔</span>: <input type="number" name="player_window_width" /></label>
				<label><span>↕</span>: <input type="number" name="player_window_height" /></label>
				<br />
				<label><input type="checkbox" name="player_window_use" /> 위치 고정 사용</label>
			</fieldset>
		</div>
	</form>
	
	<form id="sync">
		<label>싱크 입력 시 <input type="number" name="sync_insert" min="0" />줄 아래로 이동</label><br />
		<label>싱크 수정 시 <input type="number" name="sync_update" min="0" />줄 아래로 이동</label><br />
		<label>싱크 가중치: <input type="number" name="sync_weight" />ms</label><br />
		<label>싱크 조절 단위: <input type="number" name="sync_unit" min="0" />ms</label><br />
		<label>재생 이동 단위: <input type="number" name="sync_move" min="0" />ms</label><br />
		<label>싱크 언어: <input type="text" name="sync_lang" /></label><br />
		<label>싱크 태그 형태: <input type="text" name="sync_preset" style="width: 400px;" /></label><br />
		<br />
		<label><input type="checkbox" name="sync_frame" /> 프레임 단위 싱크 보정</label><br />
		<p>※ 프레임 정보를 가져오지 못했을 경우 FPS를 기준으로 프레임 단위 싱크로 보정이 들어갑니다.<br />
			　가변 프레임 영상의 경우 문제가 생길 수 있습니다.
		</p>
		<br />
		<label>키프레임을 신뢰할 수 있는 영상에 대해 <input type="number" name="sync_kLimit" min="0" />ms 범위에서 화면 싱크를 키프레임에 맞도록 보정</label><br />
		<label><input type="checkbox" name="sync_kframe" /> 키프레임을 신뢰할 수 있는 영상에 대해 자동으로 화면 싱크 처리</label><br />
		<br />
		<label><input type="checkbox" name="sync_holds" /> 싱크 일괄 이동 시 다른 홀드에도 적용</label><br />
		<p>※ 블록지정 영역에 대한 일괄 싱크 입력에는 적용되지 않습니다.</p>
		<br />
		<label>화면 싱크 매니저 섬네일 생성 크기: <input type="number" name="sync_width"   min="1" />×<input type="number" name="sync_height"   min="1" /></label><br />
		<label>화면 싱크 매니저 섬네일 출력 크기: <input type="number" name="sync_uiWidth" min="1" />×<input type="number" name="sync_uiHeight" min="1" /></label><br />
	</form>
	
	<form id="cmd">
		<table style="width: calc(100% - 17px);">
			<cols>
				<col style="width: 8%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
				<col style="width: 23%;" />
			</cols>
			<thead>
				<tr>
					<th></th>
					<th>Ctrl</th>
					<th>Alt</th>
					<th>Ctrl+Alt</th>
					<th>Ctrl+Shift</th>
				</tr>
			</thead>
		</table>
		<div id="areaTableCommand">
			<table id="tableCommand">
				<cols>
					<col style="width: 8%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
					<col style="width: 23%;" />
				</cols>
				<tbody></tbody>
			</table>
		</div>
		<input type="hidden" id="inputCommandName" />
		<label>조합 <input type="text" id="inputCommandKey" readonly style="width: 104px;" /> (← 여기를 선택한 상태에서 단축키를 입력할 수 있습니다.)</label>
		<br />
		<textarea id="inputCommandFunc"></textarea>
		
		<fieldset id="areaFunctions" style="height: 364px; overflow-y: scroll;">
			<legend>사용자 정의 명령 함수 지원</legend>
			<ul>
				<li data-input="editor.getText()">
					<h4>editor.getText() → { text: '전체_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>전체 내용을 구해옵니다.</p>
				</li>
				<li data-input="editor.setText(text, [cursor, cursor])">
					<h4>editor.setText(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>전체 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.getLine()">
					<h4>editor.getLine() → { text: '현재_줄_텍스트', selection: ['커서_시작', '커서_끝'] }</h4>
					<p>커서(끝) 줄의 내용을 가져옵니다.</p>
				</li>
				<li data-input="editor.setLine(text, [cursor, cursor])">
					<h4>editor.setLine(string '대체_텍스트', number[] ['커서_시작', '커서_끝'])</h4>
					<p>커서(끝) 줄의 내용을 교체합니다.</p>
				</li>
				<li data-input="editor.inputText(text, false)">
					<h4>editor.inputText(string '입력_텍스트', bool '커서_고정')</h4>
					<p>현재 커서 위치에 내용을 입력합니다.</p>
				</li> 
				<li data-input="editor.tagging('<i>', false)">
					<h4>editor.tagging(string '&lt;태그&gt;', bool '커서_위치부터')</h4>
					<p>커서가 있는 줄 전체, 혹은 커서 위치 이후 문자열에 태그를 입힙니다.</p>
				</li>
				<li data-input="editor.taggingRange('<u>')">
					<h4>editor.taggingRange(tag) { self.taggingRange(tag); };</h4>
					<p>tagging(string '&lt;태그&gt;', true)와 같은 동작입니다.</p>
				</li>
				<li data-input="editor.moveToSync()">
					<h4>editor.moveToSync()</h4>
					<p>현재 대사의 싱크를 재생합니다.<br />
						괄호 안에 가중치를 넣을 수 있습니다.
					</p>
				</li>
				<li data-input="editor.findSync()">
					<h4>editor.findSync()</h4>
					<p>현재 재생 중인 대사를 찾습니다.</p>
				</li>
				<li data-input="editor.deleteLine()">
					<h4>editor.deleteLine()</h4>
					<p>현재 줄을 삭제합니다.</p>
				</li>
				<li data-input="editor.insertSync()">
					<h4>editor.insertSync()</h4>
					<p>싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.insertSync(1)">
					<h4>editor.insertSync(1)</h4>
					<p>화면 싱크를 찍습니다.</p>
				</li>
				<li data-input="editor.toggleSyncType()">
					<h4>editor.toggleSyncType()</h4>
					<p>기본 싱크 ↔ 화면 싱크 토글</p>
				</li>
				<li data-input="editor.removeSync()">
					<h4>editor.removeSync()</h4>
					<p>선택 영역 싱크를 삭제합니다.</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.playOrPause()">
					<h4>SmiEditor.PlayerAPI.playOrPause()</h4>
					<p>재생/일시정지</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.play()">
					<h4>SmiEditor.PlayerAPI.play()</h4>
					<p>재생</p>
				</li>
				<li data-input="SmiEditor.PlayerAPI.stop()">
					<h4>SmiEditor.PlayerAPI.stop()</h4>
					<p>정지</p>
				</li>
				<li data-input="newFile()">
					<h4>newFile()</h4>
					<p>새 파일</p>
				</li>
				<li data-input="openFile()">
					<h4>openFile()</h4>
					<p>파일 열기</p>
				</li>
				<li data-input="saveFile()">
					<h4>saveFile()</h4>
					<p>파일 저장하기</p>
				</li>
				<li data-input="saveFile(true)">
					<h4>saveFile(true)</h4>
					<p>다른 이름으로 저장하기</p>
				</li>
				<li data-input="openSetting()">
					<h4>openSetting()</h4>
					<p>설정창 열기</p>
				</li>
				<li data-input="openAddon('~~.html')">
					<h4>openAddon("~~.html")</h4>
					<p>직접 만든 부가기능 창을 열 수 있습니다.</p>
				</li>
			</ul>
		</fieldset>
	</form>
	
	<form id="ac">
		<p>
			줄 단위로 자동완성 문자열을 설정할 수 있습니다.<br />
			'|'를 이용해 입력값과 출력값이 다르게 설정할 수 있습니다. 
		</p>
		<br />
		<label>일반 문자열 (단어 입력 중 Ctrl+스페이스바 혹은 Tab키)<br />
			이곳에 입력한 값은 맞춤법 검사기 등을 사용할 때 예외처리에도 사용됩니다.
			<textarea name="autoComplete_0_1"></textarea>
		</label>
		<label>@
			<textarea name="autoComplete_50_1"></textarea>
		</label>
		<label>#
			<textarea name="autoComplete_51_1"></textarea>
		</label>
		<label>$
			<textarea name="autoComplete_52_1"></textarea>
		</label>
		<label>%
			<textarea name="autoComplete_53_1"></textarea>
		</label>
		<label>^
			<textarea name="autoComplete_54_1"></textarea>
		</label>
		<label>&
			<textarea name="autoComplete_55_1"></textarea>
		</label>
		<label>(
			<textarea name="autoComplete_57_1"></textarea>
		</label>
		<label>)
			<textarea name="autoComplete_48_1"></textarea>
		</label>
		<label>&lt;
			<textarea name="autoComplete_188_1"></textarea>
		</label>
		<label>&gt;
			<textarea name="autoComplete_190_1"></textarea>
		</label>
	</form>
	
	<form id="replace">
		<p>
			자막 파일 저장 시 자동치환 동작 설정입니다. 
		</p>
		<label><input type="checkbox" name="saveWithNormalize" /> 특수태그 정규화 자동 적용</label><br />
		<ol id="replaceList"></ol>
		<button type="button" class="add-replace">추가</button>
	</form>
	
	<form id="style">
		<div id="style_highlight_setting">
			<div>
				<label>문법 하이라이트:
					<select name="highlight_parser">
						<option value="">사용 안 함</option>
						<option value="SyncOnly">싱크만 구분</option>
						<option value="withoutSync">싱크 제외</option>
						<option value="full">전체</option>
					</select>
				</label><br />
				<label class="for-withoutSync"><span >　　싱크 투명도:</span>
					<input type="range" name="highlight_sync" min="0" max="1" step="0.01" />
				</label>
			</div>
			<div>
				<select name="highlight_style"></select><br />
				<span>
					<label><input type="checkbox" name="highlight_enter" /> <span>줄바꿈 표시</span></label>
					<label><input type="checkbox" name="highlight_color" /> <span>색상 미리보기</span></label>
				</span>
			</div>
		</div>
		<div style="float: left;">
			<label class="for-withoutSync"><span >커서 이동 시 스크롤 여백</span>
				<input type="number" style="width: 40px;" name="scrollMargin" step="0.5" min="0" />줄
			</label>
			<br />
			<label>UI 배율
				<select name="size">
					<option value="0.8" >80%</option>
					<option value="0.9" >90%</option>
					<option value="1"  >100%</option>
					<option value="1.1">110%</option>
					<option value="1.2">120%</option>
					<option value="1.3">130%</option>
					<option value="1.4">140%</option>
					<option value="1.5">150%</option>
					<option value="1.7">170%</option>
					<option value="2.0">200%</option>
					<option value="2.5">250%</option>
					<option value="3.0">300%</option>
					<option value="4.0">400%</option>
				</select>
			</label>
		</div>
		<div style="float: left; margin-left: 38px;">
			<label>스크롤바 노출 시간
				<input type="number" style="width: 40px;" name="scrollShow" step="0.5" min="0" />초<br />
				(※ 0초일 경우 기존 형태 스크롤바)
			</label>
		</div>
		<div style="clear: both;">
			<label><input type="checkbox" name="useTab" /> 탭 사용</label>
		</div>
		<div>
			<label><input type="checkbox" name="viewer_useAlign" /> 미리보기/ASS 변환 시 줄표로 시작할 경우 왼쪽 정렬</label>
		</div>
		<fieldset id="style_color">
			<legend>색 설정</legend>
			<fieldset id="style_color_preset">
				<legend>프리셋</legend>
				<ul></ul>
				<button type="button" id="btnAddPreset">현재값 프리셋에 추가</button>
			</fieldset>
			<div id="style_color_setting">
				<label><span>기본 배경 색      </span><input type="color" name="color_background" /></label><label><span>저장되지 않음 표시</span><input type="color" name="color_notSaved"   /></label><br />
				<label><span>탭/홀드 배경 색   </span><input type="color" name="color_selector"   /></label><label><span>설정/탭 테두리    </span><input type="color" name="color_tabBorder"  /></label><br />
				<label><span>비활성 탭/홀드 색 </span><input type="color" name="color_tab"        /></label><label><span>홀드/에디터 테두리</span><input type="color" name="color_border"     /></label><br />
				<label><span>에디터 배경 색    </span><input type="color" name="color_editor"     /></label><label><span>기본 글씨/커서 색 </span><input type="color" name="color_text"       /></label><br />
				<label><span>버튼 활성 색      </span><input type="color" name="color_hover"      /></label><label><span>화면 싱크 표시    </span><input type="color" name="color_syncBorder" /></label><br />
				<label><span>싱크 역전 표현    </span><input type="color" name="color_syncError"  /></label><label><span>싱크 중복 표현    </span><input type="color" name="color_syncEqual"  /></label><br />
			</div>
		</fieldset>
		<label id="areaNewFile">새 문서
		</label>
		<fieldset id="style_ass" style="display: block;">
			<legend>ASS 기본 스타일</legend>
			<div>
				<label><span>글꼴  </span><input type="text" name="defStyle_Fontname" />　</label>
				<label><span style="width: auto;">크기　</span><input type="number" name="defStyle_Fontsize" min="1" />px</label>
				<label><input type="checkbox" name="defStyle_Bold" checked="checked" /> 굵게</label>
			</div>
			<div>
				<label><span>외곽선</span><input type="color" name="defStyle_OutlineColour"   /><input type="text" class="color" /><input type="number" name="defStyle_Outline" />px</label>
			</div>
			<div>
				<label><span>그림자</span><input type="color" name="defStyle_BackColour"      /><input type="text" class="color" /><input type="number" name="defStyle_Shadow" />px</label>
			</div>
			<div>
				<label><span>좌우 여백</span><input type="number" name="defStyle_MarginL" min="0" />px</label> /
				<label><span>상하 여백</span><input type="number" name="defStyle_MarginV" min="0" />px</label>
			</div>
		</fieldset>
		<label for="taViewerCss">미리보기</label>
		<textarea id="taViewerCss" name="viewer_css" style="height: 300px;"></textarea>
	</form>
	
	<form id="player">
		<label>동영상 파일 확장자: <input type="text" name="player_exts" style="width: calc(100% - 140px);" /></label>
		<fieldset>
			<legend>플레이어: <select name="player_control_dll"></select></legend>
			<label>실행파일: <input type="text" name="player_control_what_path" style="width: calc(100% - 170px);" /></label><button type="button" id="btnPlayerPath" style="width: 100px;">찾아보기...</button><br />
			<label><input type="checkbox" name="player_control_what_withRun"  /> 프로그램 실행 시 플레이어 실행</label><br />
			<label><input type="checkbox" name="player_control_what_withExit" /> 프로그램 종료 시 플레이어 종료</label><br />
		</fieldset>
		<span>※ 다른 플레이어를 연동하고 싶으신 분은 "프로그램 폴더\bridge\readme.txt"를 참고하시기 바랍니다.</span>
	</form>
	
	<form id="menu">
		<ol id="menuList"></ol>
		<button type="button" class="add-menu">추가</button>
	</form>
</div>
<div id="applyArea">
	<button type="button" id="btnSubmit" accesskey="S">적용(<u>S</u>)</button>
	<button type="button" id="btnLoadDefault">기본값으로</button>
	<button type="button" id="btnLoadSetting">현재 설정으로</button>
</div>
</body>
</html>