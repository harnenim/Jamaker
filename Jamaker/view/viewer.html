<html><!-- <!doctype html> 선언하면 <font size> 줄여도 줄 높이가 안 줄어듦... -->
<head>
<meta charset="utf-8">
<title>미리보기</title>
<script src="lib/SubtitleObject.js"></script>
<script>
let lastTab = null;
let time = 0;
const showText = [];
const hasLine = [];
const indexes = [];
const normalizedLines = [];
const normalizedIndex = [];

function htmlToText(html) {
    if (!window._tmp) _tmp = document.createElement("span");
    _tmp.innerHTML = html;
    return _tmp.innerText;
}

let style = null;
let setting = {}
function setSetting(jsonSetting) {
	setting = JSON.parse(jsonSetting);
	if (style == null) {
		document.head.append(style = document.createElement("style"));
	}
	style.innerHTML = ("#viewer {\nfont-size: calc(" + setting.viewer.size + "vw / 5.86);\n" + setting.viewer.css + "}");
}
let lines = [[],[],[]];
let viewer = null;
let viewers = [];
function setLines(newLines) {
	lines = (typeof newLines == "string") ? JSON.parse(newLines) : newLines;
	normalizedLines.length = 0;
	
	let receiveTime = time;
	time = -1;
	if (viewer) {
		viewer.innerHTML = "";
		viewers = [];
		for (let i = 0; i < lines.length; i++) {
			viewer.append(viewers[i] = document.createElement("div"));
		}
	}
	refreshTime(receiveTime, true); // 내용 바꿀 땐 시간 표시는 갱신 X
}
let titleTime = -1;
function refreshTime(receiveTime, withoutTitle) {
	if (receiveTime != titleTime) {
		if (!withoutTitle) {
			let h = receiveTime;
			let ms = h % 1000; h = (h - ms) / 1000;
			let s  = h %   60; h = (h -  s) /   60;
			let m  = h %   60; h = (h -  m) /   60;
			document.title = ("미리보기 - " + h + ":" + (m>9?"":"0")+m + ":" + (s>9?"":"0")+s + ":" + (ms>99?"":"0")+(ms>9?"":"0")+ms);
		}
		titleTime = receiveTime;
		
		// 갱신 딜레이, 팟플레이어 보정치 고려해서 25ms 일찍 출력함
		receiveTime += 25;
	}
	
	for (let hold = 0; hold < lines.length; hold++) {
		if (receiveTime < time || time < 0) {
			// 역방향 탐색일 경우 초기화
			indexes[hold] = -1;
			viewers[hold].innerHTML = "";
		}
		// 현재 시간 이전의 가장 마지막 싱크 찾기
		let index = indexes[hold];
		for (let j = (indexes[hold] < 0 ? 0 : indexes[hold]); j < lines[hold].length; j++) {
			if (lines[hold][j].SYNC) {
				if (lines[hold][j].SYNC > receiveTime) {
					break;
				}
				index = j;
			}
		}
		if (index == indexes[hold]) {
			// 변화 없음
			if (normalizedLines[hold]) {
				// 현재 시간 이전의 가장 마지막 싱크 찾기
				let index = normalizedIndex[hold];
				for (let j = 0; j < normalizedLines[hold].length; j++) {
					if (normalizedLines[hold][j].start > receiveTime) {
						break;
					}
					index = j;
				}
				if (index == normalizedIndex[hold]) {
					// 변화 없음
				} else {
					setTextToView(normalizedLines[hold][normalizedIndex[hold] = index].text, hold);
					time = receiveTime;
				}
			}
			continue;
		}
		indexes[hold] = index;
		if (indexes[hold] < 0) {
			setTextToView("", hold);
			time = receiveTime;
			continue;
		}
		
		normalizedLines[hold] = null;
		hasLine[hold] = false;
		let showLines = [];
		let nextSyncLine = null;
		
		{	let last = null;
			for (let j = indexes[hold] + 1; j < lines[hold].length; j++) {
				if (lines[hold][j].SYNC) {
					nextSyncLine = lines[hold][j];
					break;
				}
				let line = lines[hold][j].TEXT.split(/<br>/gi);
				for (let k = 0; k < line.length; k++) {
					if (k == 0 || k < line.length - 1 || line[k].length) {
						if (last && !htmlToText(last)) {
							showLines[showLines.length - 1] = last = (last + line[k]);
						} else {
							showLines.push(last = line[k]);
						}
					}
				}
			}
		}
		// 줄표 있을 때 왼쪽 정렬
		if (setting.viewer.useAlign && showLines.length < 4) { // 줄 개수 제한 없으면 싱크 안 찍은 전체 내용에 대해 동작해버림
			for (let k = 0; k < showLines.length; k++) {
				if (htmlToText(showLines[k][0])[0] == '-') {
					hasLine[hold] = true;
					break;
				}
			}
		}
		if (hasLine[hold]) {
			for (let j = 0; j < showLines.length; j++) {
				let line = showLines[j];
				if (htmlToText(line)[0] != '-') {
					line = "<span style='opacity: 0;'>-</span>" + line;
				}
				showLines[j] = line + "<span style='opacity: 0;'>-</span>";
			}
		}
		showText[hold] = showLines.join("<br>");
		
		// 정규화 자동 적용
		if (setting.saveWithNormalize) {
			if (nextSyncLine && (showLines.length < 16)) { // 싱크 안 찍은 줄에 fade 같은 게 들어가면 연산량 과도해질 수 있음
				let toNormalize = new SmiFile(lines[hold][indexes[hold]].TEXT + "\n" + showText[hold] + "\n" + nextSyncLine.TEXT);
				toNormalize.normalize();
				normalizedLines[hold] = toNormalize.body.slice(0, toNormalize.body.length - 1);
				showText[hold] = normalizedLines[hold][normalizedIndex[hold] = 0].text; // 일단은 첫 싱크 출력, 다음 루프에 추가로 잡아주기
			} else {
				// 종료싱크 없어도 그라데이션은 적용
				let toNormalize = new SmiFile(lines[hold][indexes[hold]].TEXT + "\n" + showText[hold]);
				toNormalize.normalize();
				showText[hold] = (normalizedLines[hold] = toNormalize.body)[normalizedIndex[hold] = 0].text;
			}
		}
		setTextToView(showText[hold], hold);
	}
	time = receiveTime;
};

function setTextToView(text, hold) {
	// RUBY태그 문법이 미묘하게 달라서 가공 필요
	text = text.replaceAll("<RP", "<!--RP").replaceAll("</RP>", "</RP-->");
	
	{	// 흔들기 효과 상하 공백줄 처리 -> 맨 윗줄만
		let showLines = text.split(/<br>/gi);
		if (lines[hold].length > 2) {
			let line = showLines;
			if (htmlToText(line) == "　") {
				if (line.indexOf("font-size:") > 0) {
					showlines[hold] = line.replaceAll("<font style=\"font-size:", "<div style=\"height:").replaceAll("</font>", "</div>");
				}
			}
		}
		text = showLines.join("<br>");
	}
	
	// 비어있으면 높이 차지하지 않게 내용 없애기
	if (!text.replaceAll("&nbsp;", " ").trim().length) {
		text = "";
	}
	
	let viewer = viewers[hold];
	viewer.innerHTML = text;
	
	// 폰트에 따른 보정
	resizeChildNodes(viewer);
	if (hasLine[hold]) {
		viewer.classList.add("has-line");
	} else {
		viewer.classList.remove("has-line");
	}
}
function resizeChildNodes(node) {
	if (!node.tagName) return; // 문자열
	if (node.tagName == "RT") return; // 후리가나 건너뛰기
	if (node.tagName == "FONT") {
		let face = node.getAttribute("face");
		if (face) {
			node.style.fontFamily = face;
		}
		let size = node.getAttribute("size");
		if (face || size) {
			face = getComputedStyle(node).fontFamily;
			let ratio = (face.indexOf("맑은 고딕") >= 0) ? 5.86 : 4.58;
			if (!size) size = opener.setting.viewer.size;
			node.style.fontSize = ('calc(' + size + 'vw / ' + ratio + ')');
		}
	}
	if (node.childNodes && node.childNodes.length) {
		node.childNodes.forEach(resizeChildNodes);
	}
}

window.addEventListener("load", () => {
	// 우클릭 방지
	document.addEventListener("contextmenu", (e) => {
		// TODO: 우클릭 메뉴 뭐라도 만들까?
		e.preventDefault();
	});
	window.onkeydown = (e) => {
		switch(e.key) {
			case "F5": return false; // F5 새로고침 방지
		}
	};
	viewer = document.getElementById("viewer");
	
	setTimeout(() => { // 초기화 이후 동작하도록 딜레이 줌
		if (opener) {
			window.PlayerAPI = opener.SmiEditor.PlayerAPI;
			opener.binder.updateViewerSetting();
			opener.SmiEditor.Viewer.refresh();
			
		} else if (window.binder && binder.onloadViewer) {
			window.PlayerAPI = {
					playOrPause: (    ) => { binder.playOrPause(); }
				,	play       : (    ) => { binder.play(); }
				,	stop       : (    ) => { binder.stop(); }
				,	moveTo     : (time) => { binder.moveTo(time); }
				,	move       : (move) => { binder.moveTo(time + move); }
			};
			binder.onloadViewer();
		}
	}, 100);
});

document.addEventListener("keydown", (e) => {
	switch (e.key) {
		case "ArrowLeft": { // ←
			if (!e.shiftKey && !e.ctrlKey && e.altKey) {
				// 뒤로
				e.preventDefault();
				PlayerAPI.move(-SmiEditor.sync.move);
				PlayerAPI.play();
			}
			break;
		}
		case "ArrowRight": { // →
			if (!e.shiftKey && !e.ctrlKey && e.altKey) {
				// 앞으로
				e.preventDefault();
				PlayerAPI.move(SmiEditor.sync.move);
				PlayerAPI.play();
			}
			break;
		}
		case "F9": { // F9: 재생/일시정지
			e.preventDefault();
			PlayerAPI.playOrPause();
			break;
		}
		case "F10": { // F10: 재생
			e.preventDefault();
			PlayerAPI.play();
			break;
		}
		case "F11": { // F11: 정지
			e.preventDefault();
			PlayerAPI.stop();
			break;
		}
	}
});
</script>
<style>
* {
	margin: 0;
	padding: 0;
	box-sizing: border-box;
}
html, body {
	width: 100%;
	height: 100%;
}
#viewer {
	position: fixed;
	top: 0;
	left: 0;
	right: 0;
	bottom: 0;
	text-align: center;
	white-space: pre;
}
#viewer div.has-line {
	text-align: left;
	width: fit-content;
	margin: 0 auto;
}
</style>
</head>
<body>
	<div id="viewer"></div>
</body>
</html>