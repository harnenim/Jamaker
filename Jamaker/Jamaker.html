<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Jamaker 샘플</title>
<!--

C# 껍데기를 거치지 않고 웹브라우저에서 돌아가도록 만든 샘플 페이지입니다.
개발 도중에는 이 페이지를 주로 이용합니다.

몇몇 단축키는 일반 웹브라우저에선 동작하지 않을 수 있습니다.

-->
<link rel="stylesheet" type="text/css" href="bridge/WebForm.css" />
<script src="view/lib/jquery-3.2.1.min.js"></script>
<script src="bridge/WinAPI.js"></script>
<script src="bridge/Binder.js"></script>
<script src="bridge/Bridge.js"></script>
<script>
Binder.prototype.moveWindow = function(name, x, y, w, h, resize) {
	this._.moveWindow(name, x, y, w, h, resize);
}
Binder.prototype.setFollowWindow = function(follow) {
	this._.setFollowWindow(follow);
}
Binder.prototype.setMenus = function(menus) {
	this._.setMenus(JSON.parse(menus));
}

Binder.prototype.focusToMenu = function(keyCode) {
	//this._.focusToMenu(keyCode);
}

Binder.prototype.repairSetting = function() {
	this._.repairSetting();
}
Binder.prototype.saveSetting = function(setting) {
	this._.saveSetting(setting);
}
Binder.prototype.setVideoExts = function(exts) {
	this._.setVideoExts(exts);
}
Binder.prototype.setPlayer = function(dll, exe, withRun, useMove) {
	this._.setPlayer(dll, exe, withRun, useMove);
}
Binder.prototype.runPlayer = function(path) {
	this._.runPlayer(path);
}

Binder.prototype.save = function(tab, text, path, type=0) { // type 0: jmk / 1: smi / 2: ass / 3: srt
	this._.requestSave(tab, text, path, type);
}
Binder.prototype.saveTemp = function(text, path) {
	this._.saveTemp(text, path);
}
Binder.prototype.openFile = function() {
	this._.openFile();
}
Binder.prototype.openFileForVideo = function() {
	this._.openFileForVideo();
}
Binder.prototype.afterInit = function() {
	this._.afterInit();
}
Binder.prototype.loadAssFile = function(path, tab) {
	// 웹버전에선 바로 같이 열리도록 연동 불가능
}
Binder.prototype.setPath = function(smiPath) {
	this._.setPath(smiPath);
}
Binder.prototype.setPathAndCheckLoadVideoFile = function(smiPath) {
	this._.setPath(smiPath);
	this._.checkLoadVideoFile();
}
Binder.prototype.loadVideoFile = function(path) {
	this._.loadVideoFile(path);
}
Binder.prototype.requestFrames = function(path) {
	this._.requestFrames(path);
}
Binder.prototype.setThumbnailSize = function(width, height) {
	// C#에서 동작
}
Binder.prototype.renderThumbnails = function(path, params) {
	this._.renderThumbnails(path, params);
}
Binder.prototype.openTempDir = function() {
	this._.openTempDir();
}
Binder.prototype.doExit = function(resetPlayer, exitPlayer) {
	this._.doExit(resetPlayer, exitPlayer);
}

Binder.prototype.log = function(msg) {
	console.log(msg);
}

// 팝업 통신
Binder.prototype.sendMsg = function(target, msg) {
	this._.sendMsg(target, msg);
}

// setting.html
Binder.prototype.getWindows = function(targets) { this._.getWindows(JSON.parse(targets)); }
Binder.prototype.selectPlayerPath = function() { alert("C#에서 동작합니다."); }

// addon 설정 용
Binder.prototype.setAfterInitAddon = function(func) { this._.setAfterInitAddon(func); }
Binder.prototype.loadAddonSetting = function(path) { this._.loadAddonSetting(path); }
Binder.prototype.saveAddonSetting = function(path, text) { this._.saveAddonSetting(path, text); }

Binder.prototype.getSubDirs = function(dir) { console.log(dir); }
Binder.prototype.searchFiles = function(dir, query) { alert("C#에서 동작합니다."); };

// viewer/finder opener 못 쓰게 될 경우 고려
Binder.prototype.updateViewerSetting  = function() { this._.updateViewerSetting(); };
Binder.prototype.updateViewerLines = function(lines) { this._.updateViewerLines(lines); };

Binder.prototype.onloadFinder  = function(last  ) { this._.onloadFinder (last  ); };
Binder.prototype.runFind	   = function(params) { this._.runFind      (params); };
Binder.prototype.runReplace    = function(params) { this._.runReplace   (params); };
Binder.prototype.runReplaceAll = function(params) { this._.runReplaceAll(params); };

// 플레이어
Binder.prototype.playOrPause = function() { this._.player.playOrPause(); }
Binder.prototype.play        = function() { this._.player.play(); }
Binder.prototype.stop        = function() { this._.player.stop(); }
Binder.prototype.moveTo  = function(time) { this._.player.moveTo(time); }

// 부가기능
Binder.prototype.runColorPicker = function() { this._.runColorPicker(); }

// 웹샘플용
Binder.prototype.openTempDir = function() { this._.openTempDir() };
Binder.prototype.exportSetting = function() { this._.exportSetting() };
Binder.prototype.importSetting = function() { this._.importSetting() };
</script>
<script src="bridge/WebForm.js"></script>
<script>
// bridge/list.txt
//const playerDlls = "NoPlayer: (없음)\n PotPlayer: 팟플레이어";
const playerDlls = "NoPlayer: (없음)\n Sample: 샘플";
const highlights = "eclipse: Eclipse \n vs: Visual Studio";

window.editor = new WebForm(); // 에디터

const window_open = function(url, name, options, opener) {
	return opener._open_(url, name, options);
}

{	// editor
	editor.player = null;
	editor.useMovePlayer = false;
	editor.strSettingJson = "불러오기 실패 예제";
	editor.strBridgeList = "NoPlayer: (없음)";
	editor.strHighlights = "eclipse: Eclipse \n vs: Visual Studio";
	
	// override
	editor.drop = async function(x, y) {
		const file = this.droppedFiles[0];
		const ext = file.name.toLowerCase();
		if (ext.endsWith(".smi")
		 || ext.endsWith(".sami")
		 || ext.endsWith(".srt")
		 || ext.endsWith(".ass")
		 || ext.endsWith(".jmk")
		 || ext.endsWith(".txt")
		) {
			await editor.loadFile(file);
			
		} else if (ext.endsWith(".fkf")) {
			await editor.script("loadFkfFile", file);
		}
	}
	
	editor.run = function() {
		this.initializeComponent();
		
		let offset = localStorage.getItem("offset.Jamaker");
		if (offset) {
			offset = offset.split(",");
			const top = Number(offset[0]);
			const left = Number(offset[1]);
			const width = Number(offset[2]);
			const height = Number(offset[3]);
			WinAPI.MoveWindow(window, left, top, width, height);
		}
		
		this.loadSetting(() => {
			editor.mainView.src = "view/editor.html";
			editor.mainView.onload = function() {
				// 브라우저 샘플에선 url 변형 필요
				editor.mainView.contentWindow._open_ = editor.mainView.contentWindow.open;
				editor.mainView.contentWindow.open = function(url, name, options) {
					if (url.substring(0, 4) != "http") {
						url = location.href.substring(0, location.href.lastIndexOf("/")) + "/view/" + url;
					}
					return editor.windows[name] = window_open(url, name, options, editor.mainView.contentWindow);
				}
				
				editor.mainView.contentWindow.binder = editor.binder = new Binder(editor);
				/*
				// 브라우저 샘플에선 이게 안 도는 경우가 있나?
				setTimeout(function() {
					editor.mainView.contentWindow.binder.initAfterLoad();
				}, 1000);
				*/
				
				const cd = editor.mainView.contentDocument;
				cd.addEventListener("dragenter", (e) => {
					e.preventDefault();
					editor.showDragging();
				});
				/*
				$(cd).on("click", "*", function() {
					$(".submenu.open").removeClass("open");
				}).on("keydown", editor.keyDownForMenu);
				*/
			};
			
			setTimeout(() => {
				// 로딩 전에 돌아가면 문제 생김
				editor.timer = setInterval(() => {
					for (let i = 0; i < editor.timerFuncs.length; i++) {
						editor.timerFuncs[i]();
					}
				}, 50);
			}, 1000);
			editor.timerFuncs = [
					() => { editor.followWindow(); }
				,	() => { editor.refreshPlayer(); }
			];
			
			// 브라우저 초기화 후 다시 돌림... 왜지?
			setTimeout(() => {
				editor.mainView.contentWindow.moveWindowsToSetting();
			}, 1000);
		});
		
		//FormClosing += new FormClosingEventHandler(BeforeExit);
		//FormClosed += new FormClosedEventHandler(WebFormClosed);
	}
	
	this.loaded = false;
	editor.initAfterLoad = function() {
		if (this.loaded) return;
		this.loaded = true;
		
		this.windows[this.mainView.contentWindow.windowName] = window;
		
		this.script("init", this.strSettingJson, false); // C#에서 객체 그대로 못 보내주므로 json string 만드는 걸로
		this.script("setPlayerDlls", this.strBridgeList);
		this.script("setHighlights", this.strHighlights);
		
		// 세팅 확인
		WinAPI.GetWindowRect(this.getHwnd("editor"), this.lastOffset);
		editor.useFollowWindow = true;
		
		// 실행 5초 후 동영상 불러온 것처럼 실행
		setTimeout(() => {
			this.script("setVideoInfo", 1920, 1080, 23976);
			this.script("eval", "for (let i = 0; i < 200000; i++) { SmiEditor.video.fs.push(Math.round(i * SmiEditor.video.FL)); }");
		}, 2000);
	};
	
	editor.refreshPlayer = function() {
		if (this.player) {
			// 플레이어 살아있음
			/*
			 * C#에선 초기화 여부 체크하는 등의 코드가 들어감
			 */
			const time = this.player.getTime();
			editor.script("refreshTime", time);
			editor.updateViewerTime(time);
		}
	}
	
	editor.beforeExit = function(e) {
		/*
		e.Cancel = true;
		Script("beforeExit");
		*/
		
		WinAPI.GetWindowRect(window, this.offset);
		localStorage.setItem("offset.Jamaker", [
				editor.offset.top
			,	editor.offset.left
			,	editor.offset.right - editor.offset.left
			,	editor.offset.bottom - editor.offset.top
		].join(","));
		
		const viewer = editor.mainView.contentWindow.SmiEditor.Viewer;
		if (viewer && viewer.window) viewer.window.close();
		
		const addon = editor.mainView.contentWindow.SmiEditor.Addon;
		if (addon && addon.window) addon.window.close();
		
		if (this.player && this.player.hwnd) this.player.hwnd.window.close();
		
		const settingWindow = editor.mainView.contentWindow.SmiEditor.settingWindow;
		if (settingWindow) settingWindow.close();
	}
	/*
	public void DoExit(bool resetPlayer, bool exitPlayer)
	
	public void WebFormClosed(object sender, FormClosedEventArgs e)
	*/
}
	
// 윈도우 그림자 여백 보정
// iframe 버전에서 호출할 경우 값 바뀔 수 있음
window.MT = 0;
window.ML = 7;
window.MR = 7;
window.MB = 9;

{	// 창 조작
	editor.hwnd = window;
	// override
	editor.getHwnd = function(name) {
		if (name == "player") {
			return this.player && this.player.hwnd && this.player.hwnd.window;
		}
		return this.super_getHwnd(name);
	}
	editor.moveWindow = function(target, x, y, width, height, resizable) {
		const hwnd = this.getHwnd(target);
		if (!target == "editor") {
			// follow window 동작 일시정지
			WinAPI.GetWindowRect(this.getHwnd("editor"), this.lastOffset);
		}
		if (!resizable) {
			// TODO: 안 됨.............
			//WinAPI.DisableResize(hwnd);
		}
		if (target == "player") {
			this.player.currentOffset.top    = y - MT;
			this.player.currentOffset.left   = x - ML;
			this.player.currentOffset.right  = x + width  + MR;
			this.player.currentOffset.bottom = y + height + MB;
			if (hwnd) {
				this.player.moveWindow();
			}
		} else {
			if (hwnd) {
				WinAPI.MoveWindow(hwnd, x - ML, y - MT, width + ML + MR, height + MB);
				if (target == "editor") {
					//this.script("setDpiBy", width);
				}
				
				// TODO C#: OnBeforePopup
				//hwnd.binder = editor.binder;
				hwnd.onload = function() {
					//hwnd.binder = editor.binder;
					setTimeout(function() {
						if (target == "finder") {
							editor.mainView.contentWindow.SmiEditor.Finder.onload();
						} else if (target == "viewer") {
							let viewer = hwnd;
							if (viewer.iframe && viewer.iframe.contentWindow) {
								viewer = viewer.iframe.contentWindow;
							}
							if (viewer.setSetting) {
								viewer.setSetting(editor.strSettingJson);
								viewer.setLines(editor.viewerLines);
							}
						}
					}, 1);
				};
			}
		}
	}
	editor.focusWindow = function(target) {
		if (target == "player") {
			return;
		}
		const hwnd = this.getHwnd(target);
		if (hwnd) {
			WinAPI.SetForegroundWindow(hwnd);
		}
	}
	editor.setFollowWindow = function(follow) {
		if (follow) {
			WinAPI.GetWindowRect(this.getHwnd("editor"), this.lastOffset);
		}
		this.useFollowWindow = follow;
	}
	editor.getWindows = function(targets) {
		for (let i = 0; i < targets.length; i++) {
			const target = targets[i];
			const hwnd = this.getHwnd(target);
			if (hwnd) {
				const targetOffset = new RECT();
				WinAPI.GetWindowRect(hwnd, targetOffset);
				this.script("afterGetWindow"
					, target
					, targetOffset.left + ML
					, targetOffset.top  + MT
					, targetOffset.right - targetOffset.left - ML - MR
					, targetOffset.bottom - targetOffset.top - MB
				);
			}
		}
	}
	
	editor.userFollowWindow = false;
	editor.lastOffset = new RECT();
	editor.offset = new RECT();
	editor.viewerOffset = new RECT();
	editor.saveSettingAfter = 0;
	editor.followWindow = function() {
		if (!this.useFollowWindow) {
			return;
		}
		
		WinAPI.GetWindowRect(this.getHwnd("editor"), this.offset);
		if (editor.lastOffset.top    != editor.offset.top
		 || editor.lastOffset.left   != editor.offset.left
		 || editor.lastOffset.right  != editor.offset.right
		 || editor.lastOffset.bottom != editor.offset.bottom) {
			const moveX = this.offset.left - this.lastOffset.left;
			const moveY = this.offset.top - this.lastOffset.top;
			
			const viewer = this.getHwnd("viewer");
			if (viewer) {
				let vMoveX = moveX;
				let vMoveY = moveY;
				
				WinAPI.GetWindowRect(this.getHwnd("viewer"), this.viewerOffset);
				if (this.viewerOffset.left - this.lastOffset.left > this.lastOffset.right - this.viewerOffset.left) {
					// 오른쪽 경계에 더 가까울 땐 오른쪽을 따라감
					vMoveX = this.offset.right - this.lastOffset.right;
				}
				if (this.viewerOffset.top - this.lastOffset.top > this.lastOffset.top - this.viewerOffset.top) {
					// 아래쪽 경계에 더 가까울 땐 아래쪽을 따라감
					vMoveY = this.offset.bottom - this.lastOffset.bottom;
				}
				WinAPI.MoveWindow(viewer, vMoveX, vMoveY, this.viewerOffset);
			}
			
			if (this.player.hwnd && this.player.hwnd.window && this.player.hwnd.window.name) {
				let pMoveX = moveX;
				let pMoveY = moveY;
				
				const playerOffset = this.player.getWindowPosition();
				if (playerOffset.left - this.lastOffset.left > this.lastOffset.right - playerOffset.left) {
					// 오른쪽 경계에 더 가까울 땐 오른쪽을 따라감
					pMoveX = this.offset.right - this.lastOffset.right;
				}
				if (playerOffset.top - this.lastOffset.top > this.lastOffset.top - playerOffset.top) {
					// 아래쪽 경계에 더 가까울 땐 아래쪽을 따라감
					pMoveY = this.offset.bottom - this.lastOffset.bottom;
				}
				this.player.moveWindow(pMoveX, pMoveY);
			}
			
			this.lastOffset.top    = this.offset.top   ;
			this.lastOffset.left   = this.offset.left  ;
			this.lastOffset.right  = this.offset.right ;
			this.lastOffset.bottom = this.offset.bottom;
			//this.saveSettingAfter = 300; // 창 이동 후 3초간 변화 없으면 설정 저장
			this.saveSettingAfter = 60; // 리프레시 주기가 C#에선 10ms였는데 여기선 50ms임
			
			this.script("refreshPaddingBottom");
			
		} else if (this.saveSettingAfter > 0) {
			if (--this.saveSettingAfter == 0) {
				WinAPI.GetWindowRect(this.getHwnd("editor"), this.offset);
				this.script("eval",
					"setting.window.x = " + (this.offset.left + ML) + ";"
				+	"setting.window.y = " + (this.offset.top  + MT) + ";"
				+	"setting.window.width = "  + (this.offset.right  - this.offset.left - ML - MR) + ";"
				+	"setting.window.height = " + (this.offset.bottom - this.offset.top  - MB) + ";"
				);
				
				const viewer = this.getHwnd("viewer");
				if (viewer) {
					WinAPI.GetWindowRect(viewer, this.viewerOffset);
					this.script("eval",
						"setting.viewer.window.x = " + (this.viewerOffset.left + ML) + ";"
					+	"setting.viewer.window.y = " + (this.viewerOffset.top  + MT) + ";"
					+	"setting.viewer.window.width = "  + (this.viewerOffset.right  - this.viewerOffset.left - ML - MR) + ";"
					+	"setting.viewer.window.height = " + (this.viewerOffset.bottom - this.viewerOffset.top  - MB) + ";"
					);
				}
				
				const player = this.getHwnd("player");
				if (player) {
					const playerOffset = this.player.currentOffset;
					WinAPI.GetWindowRect(player, playerOffset);
					this.script("eval",
						"setting.player.window.x = " + (playerOffset.left + ML) + ";"
					+	"setting.player.window.y = " + (playerOffset.top  + MT) + ";"
					+	"setting.player.window.width = "  + (playerOffset.right  - playerOffset.left - ML - MR) + ";"
					+	"setting.player.window.height = " + (playerOffset.bottom - playerOffset.top  - MB) + ";"
					);
				}
				this.script("saveSetting");
			}
		}
	};
}
{
	// TODO C#
	editor.sendMsg = function(target, msg) {
		this.getHwnd(target).sendMsg(msg);
	}
	editor.onloadFinder = function(last) {
		let finder = this.getHwnd("finder");
		if (finder.iframe && finder.iframe.contentWindow) {
			finder = finder.iframe.contentWindow;
		}
		if (finder.init) {
			finder.init(last);
			finder.binder = editor.binder;
		}
	}
	editor.runFind       = function(params) { editor.mainView.contentWindow.SmiEditor.Finder.runFind      (params); };	
	editor.runReplace    = function(params) { editor.mainView.contentWindow.SmiEditor.Finder.runReplace   (params); };	
	editor.runReplaceAll = function(params) { editor.mainView.contentWindow.SmiEditor.Finder.runReplaceAll(params); };
	
	editor.updateViewerSetting = function() {
		let viewer = this.getHwnd("viewer");
		if (viewer) {
			if (viewer.iframe && viewer.iframe.contentWindow) {
				viewer = viewer.iframe.contentWindow;
			}
			if (viewer.setSetting) {
				viewer.setSetting(editor.strSettingJson);
				viewer.setLines(editor.viewerLines);
			}
		}
	};
	editor.updateViewerTime = function(time) {
		let viewer = this.getHwnd("viewer");
		if (viewer) {
			if (viewer.iframe && viewer.iframe.contentWindow) {
				viewer = viewer.iframe.contentWindow;
			}
			if (viewer.refreshTime) {
				viewer.refreshTime(time);
			}
		}
	}
	editor.viewerLines = "[]";
	editor.updateViewerLines = function(lines) {
		this.viewerLines = lines;
		let viewer = this.getHwnd("viewer");
		if (viewer) {
			if (viewer.iframe && viewer.iframe.contentWindow) {
				viewer = viewer.iframe.contentWindow;
			}
			if (viewer.setLines) {
				viewer.setLines(lines);
			}
		}
	};
}

{	// 설정
	editor.loadSetting = function(afterSuccess) {
		let setting = localStorage.getItem("setting");
		if (setting) {
			this.strSettingJson = setting
		}
		this.strBridgeList = playerDlls;
		$.ajax({url: "view/lib/highlight/list.txt"
			,	dataType: "text"
			,	success: (highlights) => {
					editor.strHighlights = highlights;
					if (afterSuccess) {
						afterSuccess();
					}
				}
		});
	}
	editor.repairSetting = function() {
		// 백지 상태에서 시작
		this.strSettingJson = "";
		
		// TODO: 설정 파일 존재하면 삭제
		
		// 백업 파일 존재하는지 확인
		if (true) {
			// 존재하면 가져오기
			let setting = localStorage.getItem("setting.bak");
			if (setting) {
				this.strSettingJson = setting;
			}
		}
		this.script("init", this.strSettingJson, true);
	}
	editor.saveSetting = function(setting) {
		localStorage.setItem("setting", (this.strSettingJson = setting));
		this.updateViewerSetting();
	}
	editor.setVideoExts = function(exts) {
		this.videoExts = exts.split(','); // C#에서만 필요
	}
	
	editor.setPlayer = function(dll, exe, withRun, useMove) {
		if (!this.player) {
			this.player = new WebPlayerBridge(exe);
		}
		const offset = JSON.parse(editor.strSettingJson).player.window;
		this.player.currentOffset.top    = offset.y - MT;
		this.player.currentOffset.left   = offset.x - ML;
		this.player.currentOffset.right  = offset.x + offset.width  + MR;
		this.player.currentOffset.bottom = offset.y + offset.height + MB;
		if (withRun) {
			this.runPlayer(exe);
		}
		this.useMovePlayer = useMove;
	}
	editor.runPlayer = function(path) {
		if (this.player && this.player.hwnd) this.player.hwnd.run();
		// C#에선 플레이어 실행되면 브리지의 타이머에서 잡아서 크기 조절함
		if (this.useMovePlayer) {
			this.player.moveWindow();
		}
	}
	
	editor.setAfterInitAddon = function(func) {
		console.log(func);
		// C#에선 addon 로딩되면 eval 실행
	}
	editor.loadAddonSetting = function(path) {
		$.ajax({"url" : "setting/addon_" + path
			,	"dataType": "text"
			,	"success": (setting) => {
					editor.mainView.contentWindow.afterLoadAddonSetting(setting.split("\r\n").join("\n"));
				}
			,	"error": () => {
					editor.mainView.contentWindow.afterLoadAddonSetting("");
				}
		});
	}
	editor.saveAddonSetting = function(path, text) {
		editor.mainView.contentWindow.afterSaveAddonSetting();
	}
}
{	// 메뉴
	editor.menuKeys = {};
	
	editor.exportSetting = async function() {
		const fb = await window.showSaveFilePicker({types:[{description:'JSON',accept:{'text/json':['.json']}}]});
		if (fb) {
			const file = await fb.getFile();
			const stream = await fb.createWritable();
			await stream.write(this.strSettingJson);
			await stream.close();
		}
	};
	editor.importSetting = async function() {
		const fb = await window.showOpenFilePicker({types:[{description:'JSON',accept:{'text/json':['.json']}}]});
		if (fb && fb[0]) {
			const file = await fb[0].getFile();
			const text = await file.text();
			this.saveSetting(text);
			this.script("init", this.strSettingJson);
		}
	};
	$(() => {
		$(document).on("keydown", ".submenu.open li", function(e) {
			const li = $(this);
			switch (e.keyCode) {
				case 38: { // ↑
					li.prev().focus();
					break;
				}
				case 40: { // ↓
					li.next().focus();
					break;
				}
				case 37: { // ←
					li.parent().data("menu").prev().click();
					break;
				}
				case 39: { // →
					li.parent().data("menu").next().click();
					break;
				}
				case 13: { // Enter
					li.click();
					break;
				}
			}
		});
		
		$(document).on("keydown", editor.keyDownForMenu);
	});
	editor.keyDownForMenu = function(e) {
		const key = String.fromCharCode(e.keyCode);
		if (!e.shiftKey && !e.ctrlKey && e.altKey) {
			const menu = editor.menuKeys[key];
			if (menu) {
				e.preventDefault();
				editor.menustrip.openMenu(menu);
			}
		}
	}
}
{	// 파일
	const fileBuffers = [];
	let afterGetString = () => {};
	
	editor.openFile = async function() {
		const fileBuffer = await window.showOpenFilePicker({
			types: [
				{	description: "지원되는 자막 파일"
				,	accept: {
							"text/sami": [".smi", ".sami", ".jmk"]
						,	"text/srt" : [".srt"]
						,	"text/ass" : [".ass"]
					}
				}
			]
		});
		if (fileBuffer && fileBuffer[0]) {
			editor.loadFile(fileBuffer[0], true);
		}
	}
	editor.openFileForVideo = function() {
		// 파일명 수신 시 동작 설정
		editor.afterGetFileName = editor.openFileAfterGetVideoFileName;
		// player에 현재 재생 중인 파일명 요청
		editor.player.getFileName();
	}
	editor.openFileAfterGetVideoFileName = function(path) { /* Native */ }
	editor.loadFile = async function(fb, confirmed=false) {
		if (fb.createWritable) {
			const index = fileBuffers.length;
			fileBuffers.push(fb);
			const file = await fb.getFile();
			const text = await file.text();
			editor.script("openFile", index + ":" + file.name, text, false, confirmed);
		} else {
			const file = fb;
			const text = await file.text();
			editor.script("openFile", file.name, text, false, confirmed);
		}
	}
	editor.afterInit = function(limit=1) {
		/*
		C#에서 args 처리
		let count = 0;
		for (let i = 0; (i < args.length) && (count < limit); i++) {
			const path = args[i];
			const ext = path.toLowerCase();
			if (ext.endsWith(".smi") || ext.endsWith(".sami")) {
				loadFile(path);
				count++;
			} else if (ext.endsWith(".srt")) {
				loadFile(path);
				count++;
			} else if (ext.endsWith(".jmk")) {
				loadFile(path);
				count++;
			}
		}
		
		check ffmpeg도 돌림
		*/
	}
	editor.loadAssFile = async function(fb) {
		if (fb.createWritable) {
			const index = fileBuffers.length;
			fileBuffers.push(fb);
			const file = await fb.getFile();
			const text = await file.text();
			editor.script("loadAssFile", index + ":" + file.name, text);
		} else {
			const file = fb;
			const text = await file.text();
			editor.script("loadAssFile", file.name, text);
		}
	}
	editor.setPath = function(path) {
		this.smiPath = path;
		let title = "";
		if (path) {
			const paths = path.split("\\").join("/").split("/");
			title += " - " + paths[paths.length - 1];
		}
		$("title").text("Jamaker" + title);
	}
	editor.checkLoadVideoFile = function() { /* native */ }
	editor.loadVideoFile = function(path) { /* native */ }
	editor.requestFrames = function(path) { /* native */ }
	editor.renderThumbnails = function(path, params) { /* native */
		const list = params.split("\n");
		
		function sleep(sec) {
			return new Promise(resolve => setTimeout(resolve, sec * 1000));
		}
		
		setTimeout(async function() {
			for (let i = 0; i < list.length; i++) {
				const param = list[i].split(",");
				const time   = param[0];
				const length = param[1];
				const begin  = param[2];
				const end    = param[3];
				const flag   = param[4];
				
				let ms = time % 60000;
				let m = Math.floor(time / 60000);
				let h = Math.floor(m / 60);
				m %= 60;
				let timeStr = ((100 + h) * 100 + m) * 100000 + ms + "";
				timeStr = timeStr.substring(1, 3) + ":" + timeStr.substring(3, 5) + ":" + timeStr.substring(5, 7) + "." + timeStr.substring(7, 10);
				const args = "-ss {ss} -t {length} -i \"{path}\" -s 96x54 -f image2 \"tmp/thumbnails/{begin}{flag}_%d.jpg\""
				.split("{ss}"    ).join(timeStr)
				.split("{length}").join(length / 1000)
				.split("{path}"  ).join("~")
				.split("{begin}" ).join(begin)
				.split("{flag}"  ).join(flag)
				;
				console.log(args);
				await sleep(0.1);
				
				for (let index = 0; index < (end - begin); index++) {
					const from = "tmp/thumbnails/" + begin + flag + "_" + (index + 1) + ".jpg";
					const to = "tmp/thumbnails/" + (begin + index) + flag + ".jpg";
					const cmdDel = "del \"{to}\"".split("{to}").join(to);
					const cmdRen = "ren \"{from}\" \"{to}\"".split("{from}").join(from).split("{to}").join(to);
				}
				
				editor.script("startRenderThumbnails", begin, end, flag);
				setTimeout(() => {
					editor.script("startCompareThumbnails", begin, end, flag);
				}, 100);
			}
		}, 1);
	}
	const SaveOrder = function(tab, text, path, type) {
		this.tab = tab;
		this.text = text;
		this.path = path;
		this.type = type;
	}
	editor.saveOrders = [];
	editor.saveIndex = 0;
	
	editor.requestSave = async function(tab, text, path, type) {
		const order = new SaveOrder(tab, text, path, type);
		
		if (editor.saveOrders.length == 0) {
			// 저장 대기열 없으면 그냥 진행
			editor.saveOrders.push(order);
			editor.save();
			
		} else {
			let updated = false;
			for (let i = editor.saveIndex + 1; i < editor.saveOrders.length; i++) {
				const item = editor.saveOrders[i];
				if (item.tab == tab && item.type == type) {
					// 저장 대기열 중복이면 내용물 교체
					item.text = text;
					item.path = path;
					item.type = type;
					updated = true;
					break;
				}
			}
			if (!updated) {
				// 저장 대기열 추가
				editor.saveOrders.push(order);
			}
		}
	}
	editor.save = async function() {
		const order = editor.saveOrders[editor.saveIndex];
		
		const tab = order.tab;
		const path = order.path;
		const text = order.text;
		const type = order.type;
		
		const paths = path.split(":");
		if (!paths[1]) {
			// 저장 경로 없으면 대화상자 열어야 함
			editor.saveWithDialog(order);
			return;
		}
		
		const fileBuffer = fileBuffers[paths[0]];
		const stream = await fileBuffer.createWritable();
		await stream.write("\ufeff" + order.text); // BOM 넣어줌
		await stream.close();
		
		switch (type) {
			case 0: editor.setPath(paths[1]);
			        editor.script("afterSaveFile"   , tab, path); break;
			case 1: editor.script("afterSaveSmiFile", tab, path); break;
			case 2: editor.script("afterSaveAssFile", tab, path); break;
			case 3: editor.script("afterSaveSrtFile", tab, path); break;
		}
		editor.afterSave();
	}
	editor.afterSave = function() {
		if (++editor.saveIndex < editor.saveOrders.length) {
			// 저장 대기열 있으면 다음 순서 진행
			editor.save();
		} else {
			// 저장 끝났으면 대기열 초기화
			editor.saveOrders.length = editor.saveIndex = 0;
		}
	}
	editor.saveWithDialog = async function(order) {
		let fileBuffer = null;
		try  {
			const types = [];
			switch (order.type) {
				case 0:
				case 1: types.push({ description: "SAMI 자막", accept: { "text/sami": [".smi", ".sami"] } }); break;
				case 2: types.push({ description: "ASS 자막" , accept: { "text/ass" : [".ass"] } }); break;
				case 3: types.push({ description: "SRT 자막" , accept: { "text/srt" : [".srt"] } }); break;
			}
			if (order.type == 0) {
				types.push({ description: "자막 프로젝트", accept: { "text/sami": [".jmk"] } });
			}
			fileBuffer = await window.showSaveFilePicker({ types: types });
		} catch (e) {
			console.log(e);
		}
		if (fileBuffer) {
			const index = fileBuffers.length;
			fileBuffers.push(fileBuffer);
			const file = await fileBuffer.getFile();
			
			// 현재 저장 명령 갱신 후 재실행
			order.path = index + ":" + file.name;
			editor.save();
			
		} else {
			// 저장 취소
			editor.afterSave();
		}
	}
	editor.saveTemp = function(text, path) {
		path = path.split(":");
		const filename = path[1] ? path[1] : path[0];
//		const key = "tmp_" + new Date().getTime() + "_" + filename;
		const key = "tmp_" + filename;
		
		const tmpKeys = localStorage.getItem("tmpKeys");
		const keys = tmpKeys ? tmpKeys.split(":") : [];
		keys.push(key);
		localStorage.setItem("tmpKeys", keys.join(":"));
		localStorage.setItem(key, text);
	}
	editor.openTempDir = function() {
		const hwnd = window.open("../bridge/tempDir.html", "tempDir", "location=no,width=1,height=1");
		const rect = editor.mainView.contentWindow.setting.player.window;
		WinAPI.MoveWindow(hwnd, rect.x + 40, rect.y + 40, rect.width - 80, rect.height - 80);
	}
	
	editor.runColorPicker = function() {
		const color = prompt("색상 입력 테스트", "#ABCDEF");
		editor.script("SmiEditor.inputText", color);
	}
}
{	// Designer
	editor.initializeComponent = function() {
		this.super_initializeComponent();
		
		this.layerForDrag.css({
				padding: 80
			,	textAlign: "center"
			,	fontSize: 20
		}).html("웹 간이 버전에서 드래그로 열 경우<br />저장 파일을 재지정해줘야 합니다.");
		/*
		$("body").append((this.menustrip = new MenuStrip()).view);
		this.mainView.style.top = "20px";
		this.mainView.style.height = "calc(100% - 20px)";
		*/
	}
}
$(() => {
	editor.run();
	window.addEventListener("beforeunload", (e) => {
		editor.beforeExit(e);
	});
});
</script>
</head>
<body></body>
</html>